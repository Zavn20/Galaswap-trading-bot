<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>GalaSwap Trading Bot v9.1.4 - Force Cache Refresh</title>
    <!-- Version: 9.1 - Button Fix Update -->
    <script src="https://unpkg.com/@gala-chain/api@latest/dist/index.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="https://unpkg.com/elliptic@6.5.4/dist/elliptic.min.js"></script>
    <script src="https://unpkg.com/js-sha3@0.8.0/dist/sha3.min.js"></script>
    <script src="https://unpkg.com/json-stringify-deterministic@1.0.1/index.js"></script>
    <script src="enhanced-statistics.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
            width: 100%;
            max-width: 100%;
            overflow-x: hidden;
        }
        .container {
            width: 100%;
            max-width: 100%;
            min-width: 100%;
            margin: 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 0px;
            padding: 0px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            height: 100vh;
            max-height: 100vh;
            overflow-y: auto;
            display: grid;
            grid-template-rows: auto auto auto 1fr;
            gap: 10px;
            row-gap: 10px;
            box-sizing: border-box;
        }
        
        /* Eliminate any spacing between grid rows - EXCEPT bottom panels */
        .container > *:not(.bottom-panels-container) {
            margin: 0px !important;
            padding: 0px !important;
        }
        
        /* Ensure bottom panels have proper top margin */
        .container > .bottom-panels-container {
            margin-top: 20px !important;
            padding-top: 0px !important;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0px;
            padding: 10px 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 0px;
            color: white;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }
        .header-center {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0 30px;
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .header-left {
            flex: 1;
        }
        .header-right {
            flex: 0 0 auto;
            text-align: right;
            min-width: 300px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .header h1 {
            margin: 0;
            font-size: 1.4em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            line-height: 1.1;
            font-weight: bold;
        }
        .wallet-header-item {
            margin: 4px 0;
            font-size: 14px;
            line-height: 1.3;
            font-weight: 500;
        }
        .header-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background: #2196F3;
            color: white;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            margin: 3px;
            min-height: 32px;
            transition: all 0.3s ease;
        }
        .header-btn:hover {
            opacity: 0.8;
        }
        .status-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 6px;
            margin-bottom: 10px;
            padding: 8px;
        }
        .status-card {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 6px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.3);
            display: flex;
            flex-direction: column;
            justify-content: center;
            min-height: 60px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .status-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s ease;
        }
        
        .status-card:hover::before {
            left: 100%;
        }
        
        .status-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            border-color: rgba(255, 215, 0, 0.5);
        }
        .status-card h3 {
            margin: 0 0 4px 0;
            color: #ffd700;
            font-size: 11px;
            line-height: 1.1;
            font-weight: bold;
        }
        .status-card .value {
            font-size: 14px;
            font-weight: bold;
            color: #fff;
            transition: color 0.3s ease;
            line-height: 1.1;
        }
        
        .status-card .value.positive {
            color: #4CAF50;
        }
        
        .status-card .value.negative {
            color: #f44336;
        }
        
        .status-card .value.warning {
            color: #ff9800;
        }
        .button-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 0px;
            padding: 0 4px;
        }
        .button-section {
            margin-bottom: 0px;
            padding: 4px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            height: fit-content;
            min-height: auto;
            max-height: none;
        }
        .button-section h4 {
            margin: 0 0 6px 0;
            color: #ffd700;
            font-size: 14px;
            line-height: 1.1;
            font-weight: bold;
        }
        .button-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: flex-start;
            margin: 0px 0;
            padding: 4px;
            height: fit-content;
            min-height: auto;
            max-height: none;
        }
        button {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            line-height: 1.1;
            min-height: 36px;
            min-width: 100px;
        }
        .start-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }
        .stop-btn {
            background: linear-gradient(45deg, #f44336, #da190b);
            color: white;
        }
        .config-btn {
            background: linear-gradient(45deg, #2196F3, #1976D2);
            color: white;
        }
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            filter: brightness(1.1);
        }
        
        button:active {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        .trading-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0px;
            align-items: stretch;
            height: 280px;
            min-height: 280px;
            max-height: 280px;
            margin: 0px 0px 20px 0px;
            padding: 0px;
            width: 100%;
        }
        
        /* Override grid alignment for the right panel */
        .trading-grid .panel:last-child {
            grid-row: 1;
            align-self: start;
        }
        .three-panel-grid {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 0px;
            margin-bottom: 0px;
            width: 100%;
            max-width: 100%;
            align-items: stretch;
        }
        
        /* Top row: 25% - 50% - 25% (Market Data - Market Analysis - Trading Signals) */
        .top-row-grid {
            display: grid !important;
            grid-template-columns: 1fr 2fr 1fr !important;
            gap: 15px !important;
            margin-bottom: 0px !important;
            width: 100% !important;
            max-width: 100% !important;
            align-items: stretch !important;
            height: 100% !important;
            min-height: 100% !important;
            max-height: 100% !important;
            overflow: hidden !important;
            padding: 15px !important;
        }
        
        /* Ensure proper panel order for 3-panel layout */
        .top-row-grid .panel:nth-child(1) {
            grid-column: 1 / 2;
            height: 100% !important;
            min-height: 100% !important;
            max-height: 100% !important;
            width: 100% !important;
            max-width: 100% !important;
            overflow-y: auto !important;
        }
        
        .top-row-grid .panel:nth-child(2) {
            grid-column: 2 / 3;
            height: 100% !important;
            min-height: 100% !important;
            max-height: 100% !important;
            width: 100% !important;
            max-width: 100% !important;
            overflow-y: auto !important;
        }
        
        .top-row-grid .panel:nth-child(3) {
            grid-column: 3 / 4;
            height: 100% !important;
            min-height: 100% !important;
            max-height: 100% !important;
            width: 100% !important;
            max-width: 100% !important;
            overflow-y: auto !important;
        }
        
        /* Bottom row: 33% - 33% - 33% (Trade Statistics - Performance Metrics - Risk Management) */
        .bottom-row-grid {
            display: grid !important;
            grid-template-columns: 1fr 1fr 1fr !important;
            gap: 15px !important;
            margin-bottom: 0px !important;
            width: 100% !important;
            max-width: 100% !important;
            align-items: stretch !important;
            height: 100% !important;
            min-height: 100% !important;
            max-height: 100% !important;
            padding: 15px !important;
        }
        
        /* Ensure bottom row panel takes full width */
        .bottom-row-grid .panel {
            width: 100% !important;
            max-width: 100% !important;
        }
        
        /* Ensure proper panel order for bottom row 3-panel layout */
        .bottom-row-grid .panel:nth-child(1) {
            grid-column: 1 / 2;
        }
        
        .bottom-row-grid .panel:nth-child(2) {
            grid-column: 2 / 3;
        }
        
        .bottom-row-grid .panel:nth-child(3) {
            grid-column: 3 / 4;
        }
        
        /* Make all bottom panels have the same height */
        .three-panel-grid .panel,
        .top-row-grid .panel,
        .bottom-row-grid .panel {
            min-width: 0;
            width: 100%;
            flex: 1;
            box-sizing: border-box;
            height: 100%;
            min-height: 100%;
            max-height: 100%;
            overflow-y: auto;
        }
        
        /* Force top row panels to have equal heights */
        .top-row-grid .panel {
            height: 300px !important;
            min-height: 300px !important;
            max-height: 300px !important;
        }
        
        /* Ensure bottom panels container takes full width */
        .bottom-panels-container .three-panel-grid,
        .bottom-panels-container .top-row-grid,
        .bottom-panels-container .bottom-row-grid {
            width: 100% !important;
            max-width: 100% !important;
            box-sizing: border-box;
        }
        
        /* Force all panels to use full width */
        .bottom-panels-container .panel {
            width: 100% !important;
            max-width: 100% !important;
            overflow: hidden !important;
            box-sizing: border-box !important;
        }
        
        /* Force bottom panels to be more compact and fill space */
        .bottom-panels-container .panel {
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        /* All bottom panels have identical dimensions - force equal heights */
        .bottom-panels-container .panel {
            width: 100% !important;
            height: 280px !important;
            min-width: 0 !important;
            min-height: 280px !important;
            max-width: none !important;
            max-height: 280px !important;
            display: flex !important;
            flex-direction: column !important;
            align-items: stretch !important;
            justify-content: stretch !important;
            box-sizing: border-box !important;
            margin: 0 !important;
            padding: 15px !important;
            overflow: hidden !important;
        }
        
        /* Force top row grid container height */
        .bottom-panels-container .top-row-grid {
            height: 200px !important;
            min-height: 200px !important;
            max-height: 200px !important;
        }
        
        /* Reduce internal spacing in bottom panels */
        .bottom-panels-container .panel h3 {
            margin: 0 0 12px 0;
            padding: 8px 0;
            font-size: 14px;
            flex-shrink: 0;
            line-height: 1.2;
            color: #ffd700;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            font-weight: bold;
        }
        
        .bottom-panels-container .panel > div {
            flex: 1 !important;
            width: 100% !important;
            height: 240px !important;
            min-width: 0 !important;
            min-height: 0 !important;
            max-width: none !important;
            max-height: 240px !important;
            overflow-y: auto !important;
            overflow-x: hidden !important;
            display: flex !important;
            flex-direction: column !important;
            box-sizing: border-box !important;
            margin: 0 !important;
            padding: 0 !important;
        }
        
        .bottom-panels-container .summary-item {
            padding: 3px 0;
            margin: 0;
            font-size: 0.9em;
            line-height: 1.3;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .bottom-panels-container .summary-item:last-child {
            border-bottom: none;
        }
        
        .bottom-panels-container .summary-label {
            font-weight: 600;
            color: #ffd700;
            font-size: 0.85em;
        }
        
        .bottom-panels-container .summary-value {
            font-weight: bold;
            color: #ffffff;
            font-size: 0.9em;
        }
        
        .bottom-panels-container .token-item {
            padding: 2px 0;
            margin: 0;
            font-size: 0.8em;
            line-height: 1.2;
        }
        
        .bottom-panels-container .market-item {
            padding: 2px 0;
            margin: 0;
            font-size: 0.8em;
            line-height: 1.2;
        }
        
        /* Ensure content areas fill panel height uniformly */
        .bottom-panels-container .market-data,
        .bottom-panels-container .token-list,
        .bottom-panels-container .portfolio-summary,
        .bottom-panels-container .balance-list {
            width: 100% !important;
            height: 100% !important;
            min-width: 0 !important;
            min-height: 0 !important;
            max-width: none !important;
            max-height: 100% !important;
            overflow-y: auto !important;
            overflow-x: hidden !important;
            box-sizing: border-box !important;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            padding: 8px;
            flex: 1 !important;
            margin: 0 !important;
        }
        
        /* Style for the combined bottom panel */
        .bottom-row-grid .panel h3 {
            text-align: center;
            font-size: 0.9em;
            margin: 0;
            padding: 2px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .bottom-row-grid .panel h4 {
            margin: 5px 0 3px 0;
            color: #ffd700;
            font-size: 0.8em;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 2px;
        }
        
        /* Force bottom panels to fill entire width */
        .bottom-panels-container {
            width: 100% !important;
            max-width: 100% !important;
            margin: 0 !important;
            padding: 0 !important;
        }
        
        .bottom-panels-container .three-panel-grid {
            width: 100% !important;
            max-width: 100% !important;
            margin: 0 !important;
            padding: 0 !important;
        }
        
        /* Bottom panels container - Perfect 2x3 grid with fixed heights */
        .bottom-panels-container {
            display: grid !important;
            grid-template-columns: 1fr 1fr 1fr !important;
            grid-template-rows: 280px 280px !important;
            gap: 15px !important;
            width: 100% !important;
            max-width: 100% !important;
            margin: 25px 0 0 0 !important;
            padding: 15px !important;
            box-sizing: border-box !important;
            height: 100% !important;
            min-height: 600px !important;
            flex: 1 !important;
            align-items: stretch !important;
            justify-items: stretch !important;
            align-content: stretch !important;
            justify-content: stretch !important;
            position: relative !important;
            overflow: hidden !important;
        }
        
        /* Force equal row heights and prevent content overflow */
        .bottom-panels-container > .panel:nth-child(1),
        .bottom-panels-container > .panel:nth-child(2),
        .bottom-panels-container > .panel:nth-child(3) {
            grid-row: 1 / 2;
            grid-column: auto;
            height: 280px !important;
            max-height: 280px !important;
            overflow: hidden !important;
            position: relative !important;
        }
        
        .bottom-panels-container > .panel:nth-child(4),
        .bottom-panels-container > .panel:nth-child(5) {
            grid-row: 2 / 3;
            grid-column: auto;
            height: 280px !important;
            max-height: 280px !important;
            overflow: hidden !important;
            position: relative !important;
        }
        
        /* Token Balances & Portfolio panel - make it taller to match other panels */
        .bottom-panels-container > .panel:nth-child(6) {
            grid-row: 2 / 3;
            grid-column: auto;
            height: 280px !important;
            max-height: 280px !important;
            overflow: hidden !important;
            position: relative !important;
        }
        
        /* Specific positioning for each panel */
        .bottom-panels-container > .panel:nth-child(1) { grid-column: 1; }
        .bottom-panels-container > .panel:nth-child(2) { grid-column: 2; }
        .bottom-panels-container > .panel:nth-child(3) { grid-column: 3; }
        .bottom-panels-container > .panel:nth-child(4) { grid-column: 1; }
        .bottom-panels-container > .panel:nth-child(5) { grid-column: 2; }
        .bottom-panels-container > .panel:nth-child(6) { grid-column: 3; }
        
        /* Responsive design for smaller screens */
        @media (max-width: 1200px) {
            .container {
                min-width: 800px;
                max-width: 98vw;
            }
        }
        
        @media (max-width: 1200px) {
            .three-panel-grid {
                grid-template-columns: 1fr 2fr 1fr;
                gap: 10px;
            }
            .button-row {
                grid-template-columns: 1fr;
                gap: 10px;
            }
        }
        @media (max-width: 900px) {
            .trading-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            .three-panel-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            .container {
                min-width: 600px;
                padding: 20px;
            }
        }
        .panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        /* Make button sections ultra-compact */
        .button-section * {
            margin-bottom: 0 !important;
            padding-bottom: 0 !important;
        }
        
        .button-section h4 {
            margin-bottom: 4px !important;
        }
        
        .button-section .button-group {
            margin-bottom: 0 !important;
            padding-bottom: 0 !important;
        }
        
        /* Remove conflicting CSS for bottom panels */
        
        /* Force all log containers to maintain height */
        #tradingLog, #swapsLog, #debugLog, #transactionHistory {
            height: 250px !important;
            min-height: 250px !important;
            max-height: 250px !important;
        }
        
        /* Ultra-specific targeting for logs section */
        .trading-grid > div:first-child > div:last-child {
            height: 280px !important;
            min-height: 280px !important;
            max-height: 280px !important;
        }
        
        .trading-grid > div:first-child > div:last-child > div:last-child {
            height: 250px !important;
            min-height: 250px !important;
            max-height: 250px !important;
        }
        
        .trading-grid > div:first-child > div:last-child > div:last-child > div {
            height: 250px !important;
            min-height: 250px !important;
            max-height: 250px !important;
        }
        
        /* Force logs panel to be compact */
        .trading-grid .panel:first-child {
            height: 280px !important;
            min-height: 280px !important;
            max-height: 280px !important;
        }
        
        .tab-container {
            height: 260px !important;
            min-height: 260px !important;
            max-height: 260px !important;
        }
        
        .log {
            height: 230px !important;
            min-height: 230px !important;
            max-height: 230px !important;
            line-height: 1.3 !important;
        }
        
        .log div {
            line-height: 1.2 !important;
            margin: 0 !important;
            padding: 2px 0 !important;
        }
        
        /* Force the entire trading grid to be taller */
        .trading-grid {
            min-height: auto !important;
        }
        
        /* Make sure the logs panel takes up most of the space */
        .trading-grid .panel:first-child {
            grid-row: 1 / -1;
        }
        
        /* Make the right panel (Token Balances) more compact */
        .trading-grid .panel:last-child {
            height: fit-content !important;
            min-height: auto !important;
            max-height: none !important;
        }
        
        /* Ensure Token Balances panel has no height constraints */
        .trading-grid .panel:last-child .balance-list {
            height: auto !important;
            min-height: auto !important;
            max-height: none !important;
        }
        
        /* Force the right panel to be as compact as possible */
        .trading-grid .panel:last-child {
            height: fit-content !important;
            min-height: auto !important;
            max-height: none !important;
            align-self: start !important;
            flex-shrink: 1 !important;
            flex-grow: 0 !important;
        }
        
        /* Ultra-aggressive panel compactness */
        .trading-grid .panel:last-child * {
            margin-bottom: 0 !important;
            padding-bottom: 0 !important;
        }
        
        /* Remove any remaining spacing */
        .trading-grid .panel:last-child .portfolio-summary-section:last-child {
            margin-bottom: 0 !important;
            padding-bottom: 0 !important;
            border-bottom: none !important;
        }
        
        /* Remove any padding/margin that might add space */
        .trading-grid .panel:last-child .portfolio-summary-section {
            margin-bottom: 0 !important;
            padding-bottom: 0 !important;
        }
        .panel h3 {
            margin-top: 0;
            color: #ffd700;
            border-bottom: 1px solid rgba(255, 215, 0, 0.3);
            padding-bottom: 1px;
            font-size: 0.7em;
        }
        
        /* Aggressive gap elimination for trading-grid */
        .trading-grid .panel {
            margin: 0px !important;
            padding: 0px !important;
        }
        
        .trading-grid .panel:first-child {
            margin-top: 0px !important;
            padding-top: 0px !important;
        }
        
        /* Eliminate spacing between button-row and trading-grid */
        .button-row + .trading-grid {
            margin-top: 0px !important;
            padding-top: 0px !important;
        }
        
        .button-row {
            margin-bottom: 0px !important;
            padding-bottom: 0px !important;
        }
        .token-list {
            height: 400px;
            overflow-y: auto;
        }
        .balance-list {
            height: auto;
            overflow-y: visible;
        }
        
        .market-data {
            height: 400px;
            overflow-y: auto;
        }
        
        .market-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 2px 4px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background-color 0.3s ease;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            overflow: hidden;
        }
        
        .market-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }
        
        .market-item .token-name {
            font-weight: 600;
            color: #ffd700;
            flex: 1;
        }
        
        .market-item .price {
            font-weight: 500;
            color: #ffffff;
            margin: 0 10px;
        }
        
        .market-item .change {
            font-weight: 600;
            padding: 1px 3px;
            border-radius: 2px;
            font-size: 0.6em;
        }
        
        .market-item .change.positive {
            color: #00ff88;
            background-color: rgba(0, 255, 136, 0.1);
        }
        
        .market-item .change.negative {
            color: #ff6b6b;
            background-color: rgba(255, 107, 107, 0.1);
        }
        
        .market-item .change.neutral {
            color: #888;
            background-color: rgba(136, 136, 136, 0.1);
        }
        
        .portfolio-summary-section {
            margin-top: 4px;
            padding-top: 3px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .portfolio-summary-section h4 {
            margin: 0 0 5px 0;
            color: #ffd700;
            font-size: 1.0em;
            font-weight: 600;
        }
        
        .portfolio-summary-section .portfolio-summary {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 5px;
        }
        
        .portfolio-summary-section .summary-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 3px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .portfolio-summary-section .summary-item:last-child {
            border-bottom: none;
        }
        
        .portfolio-summary-section .summary-label {
            font-size: 0.8em;
            color: #ccc;
        }
        
        .portfolio-summary-section .summary-value {
            font-weight: 600;
            color: #ffffff;
            font-size: 0.9em;
        }
        .token-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 2px 4px;
            margin: 1px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            border-left: 2px solid transparent;
            min-height: 16px;
            box-sizing: border-box;
            width: 100%;
            max-width: 100%;
            overflow: hidden;
        }
        .token-item.opportunity {
            border-left-color: #4CAF50;
            background: rgba(76, 175, 80, 0.2);
        }
        .token-item.risk {
            border-left-color: #f44336;
            background: rgba(244, 67, 54, 0.2);
        }
        .token-name {
            font-weight: bold;
            font-size: 1.0em;
            flex: 0 0 auto;
            min-width: 60px;
        }
        .token-price {
            color: #ffd700;
            font-size: 0.95em;
            flex: 1;
            text-align: center;
            margin: 0 10px;
        }
        .token-change {
            font-size: 0.9em;
            min-width: 60px;
            text-align: right;
            white-space: nowrap;
        }
        .positive { color: #4CAF50; }
        .negative { color: #f44336; }
        .log {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
            padding: 15px 20px;
            height: 400px !important;
            min-height: 400px !important;
            max-height: 400px !important;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            width: 100%;
            box-sizing: border-box;
            margin-right: 5px;
            flex: 1 !important;
        }
        .log-entry {
            margin: 3px 0;
            padding: 6px 10px;
            border-radius: 2px;
            word-wrap: break-word;
            white-space: pre-wrap;
            width: 100%;
            box-sizing: border-box;
        }
        
        /* Tabbed Interface Styles */
        .tab-container {
            margin-top: 3px;
            height: 300px !important;
            min-height: 300px !important;
            max-height: 300px !important;
        }
        .tab-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }
        .tab-button {
            padding: 10px 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
            min-height: 36px;
        }
        .tab-button:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        .tab-button.active {
            background: rgba(255, 215, 0, 0.3);
            border-color: #ffd700;
            color: #ffd700;
        }
        .tab-content {
            position: relative;
            flex: 1 !important;
            display: flex !important;
            flex-direction: column !important;
        }
        .tab-panel {
            display: none !important;
            width: 100%;
            height: 100%;
        }
        .tab-panel.active {
            display: flex !important;
            flex-direction: column !important;
            flex: 1 !important;
            width: 100% !important;
            height: 100% !important;
        }
        .log-info { background: rgba(33, 150, 243, 0.2); }
        .log-success { background: rgba(76, 175, 80, 0.2); }
        .log-warning { background: rgba(255, 193, 7, 0.2); }
        .log-error { background: rgba(244, 67, 54, 0.2); }
        
        .portfolio-summary {
            padding: 8px;
            min-height: auto !important;
            height: auto !important;
        }
        .summary-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin: 1px 0;
        }
        .summary-item:last-child {
            border-bottom: none;
        }
        .summary-label {
            font-weight: bold;
            color: #ffd700;
        }
        .summary-value {
            font-size: 1.1em;
            font-weight: bold;
            color: white;
        }
        .summary-value.positive { color: #4CAF50; }
        .summary-value.negative { color: #f44336; }
        .config-panel {
            display: none;
            background: rgba(0, 0, 0, 0.5);
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
        }
        .config-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            color: #333;
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            width: 90%;
        }
        .config-content h3 {
            margin-top: 0;
            color: #333;
        }
        .form-group {
            margin-bottom: 20px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .form-group input, .form-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        .close-btn {
            float: right;
            background: #f44336;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
        }
        @media (max-width: 768px) {
            .trading-grid {
                grid-template-columns: 1fr;
            }
            .controls {
                flex-direction: column;
            }
        }
        
        /* ULTRA-SPECIFIC OVERRIDE: Force proper spacing between logs and bottom panels */
        .trading-grid {
            margin-bottom: 25px !important;
        }
        
        .bottom-panels-container {
            margin-top: 25px !important;
            padding-top: 15px !important;
        }
        
        /* Ensure no other rules override this spacing */
        .container .trading-grid + .bottom-panels-container {
            margin-top: 25px !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-left">
                <h1>🚀 GalaSwap Trading Bot v9.1</h1>
                <p>Real On-Chain Trading via Local Server</p>
                <p id="modeBanner" style="font-size: 12px; color: #4caf50; background: rgba(76, 175, 80, 0.1); padding: 5px; border-radius: 3px; margin: 5px 0;">🛡️ CONSERVATIVE MODE - Safe & Steady Trading</p>
                <p id="serverStatus" style="font-size: 11px; color: #ff9800; background: rgba(255, 152, 0, 0.1); padding: 5px; border-radius: 3px; margin: 5px 0; border: 1px solid #ff9800;">🔄 Server Status: Checking connection...</p>
                <p style="font-size: 12px; color: #555;">Version 9.1.4 - Force Cache Refresh</p>
                <button onclick="testModeSwitching()" style="font-size: 10px; padding: 2px 4px; margin: 2px 0; background: #2196f3; color: white; border: none; border-radius: 2px; cursor: pointer;">Test Mode Switch</button>
            </div>
            <div class="header-center">
                <div class="mode-toggles" style="display: flex; gap: 8px; justify-content: center;">
                    <div class="conservative-mode-toggle" style="text-align: center; padding: 8px; background: rgba(76, 175, 80, 0.2); border-radius: 6px; border: 1px solid #4caf50; margin: 5px 0; flex: 1;">
                        <label style="color: #4caf50; font-weight: bold; font-size: 12px; cursor: pointer;">
                            <input type="radio" name="tradingMode" value="conservative" id="conservativeModeToggle" checked onchange="setTradingMode('conservative')" style="margin-right: 4px;"> 
                            🛡️ CONSERVATIVE
                        </label>
                        <div style="font-size: 9px; color: #ccc; margin-top: 2px;">
                            Safe & Steady
                        </div>
                    </div>
                    <div class="trade-cap-toggle" style="text-align: center; padding: 8px; background: rgba(255, 193, 7, 0.2); border-radius: 6px; border: 1px solid #ffc107; margin: 5px 0; flex: 1;">
                        <label style="color: #ffc107; font-weight: bold; font-size: 12px; cursor: pointer;">
                            <input type="radio" name="tradingMode" value="tradecap" id="tradeCapToggle" onchange="setTradingMode('tradecap')" style="margin-right: 4px;"> 
                            🔒 TRADE CAP
                        </label>
                        <div style="font-size: 9px; color: #ccc; margin-top: 2px;">
                            Small Testing
                        </div>
                    </div>
                    <div class="competition-mode-toggle" style="text-align: center; padding: 8px; background: rgba(156, 39, 176, 0.2); border-radius: 6px; border: 1px solid #9c27b0; margin: 5px 0; flex: 1;">
                        <label style="color: #9c27b0; font-weight: bold; font-size: 12px; cursor: pointer;">
                            <input type="radio" name="tradingMode" value="competition" id="competitionModeToggle" onchange="setTradingMode('competition')" style="margin-right: 4px;"> 
                            🏆 COMPETITION
                        </label>
                        <div style="font-size: 9px; color: #ccc; margin-top: 2px;">
                            High-Frequency
                        </div>
                    </div>
                </div>
            </div>
            <div class="header-right">
                <div class="wallet-header-info" id="walletHeaderInfo" style="display: none;">
                    <div class="wallet-header-item">
                        <strong>Wallet:</strong> <span id="walletAddressHeader">-</span>
                    </div>
                    <div class="wallet-header-item">
                        <strong>GALA:</strong> <span id="galaBalanceHeader">-</span>
                    </div>
                    <div class="wallet-header-item">
                        <strong>Status:</strong> <span id="connectionStatusHeader">-</span>
                    </div>
                    <div class="wallet-header-item">
                        <strong>Signing:</strong> <span id="signingStatusHeader">❌ No Key</span>
                    </div>
                    <button onclick="disconnectWallet()" class="header-btn" style="background: #f44336; margin-top: 5px;">🔌 Disconnect</button>
                </div>
                <div class="wallet-header-connect" id="walletHeaderConnect">
                    <button onclick="connectWallet()" class="header-btn">🔗 Connect Wallet</button>
                </div>
                <!-- Private key input - always visible -->
                <div style="margin-top: 15px; background: rgba(255, 255, 255, 0.05); padding: 12px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1);">
                    <div style="margin-bottom: 8px; font-size: 12px; color: #ffd700; font-weight: bold;">🔑 Private Key Management</div>
                    <input type="password" id="privateKeyInput" placeholder="Private key (0x...)" style="width: 280px; padding: 10px; border: 1px solid #ccc; border-radius: 6px; font-family: monospace; font-size: 12px; background: rgba(255, 255, 255, 0.9); color: #333;">
                    <div style="margin-top: 8px;">
                        <button onclick="setPrivateKey()" class="header-btn" style="background: #4caf50; margin-right: 8px;">🔑 Set Key</button>
                        <button onclick="clearPrivateKey()" class="header-btn" style="background: #f44336;">🗑️ Clear Key</button>
                    </div>
                    <div id="walletAddressDisplay" style="margin-top: 8px; font-size: 11px; color: #ffd700; background: rgba(255, 215, 0, 0.1); padding: 5px; border-radius: 3px; border: 1px solid rgba(255, 215, 0, 0.3);">
                        🔗 Connected Wallet: <span id="walletAddressText">Not connected</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="status-panel">
            <div class="status-card">
                <h3>⚡ Bot Status</h3>
                <div class="value" id="botStatus" style="color: #f44336;">Stopped</div>
                <div style="font-size: 10px; color: #ccc; margin-top: 4px;">Ready to trade</div>
            </div>
            <div class="status-card">
                <h3>💰 Portfolio Value</h3>
                <div class="value" id="portfolioValue">$0.00</div>
                <div style="font-size: 10px; color: #ccc; margin-top: 4px;">Real-time value</div>
            </div>
            <div class="status-card">
                <h3>📈 Total Profit</h3>
                <div class="value" id="totalProfit">$0.00</div>
                <div style="font-size: 10px; color: #ccc; margin-top: 4px;">All-time profit</div>
            </div>
            <div class="status-card">
                <h3>🎯 Active Trades</h3>
                <div class="value" id="activeTrades">0</div>
                <div style="font-size: 10px; color: #ccc; margin-top: 4px;">Currently running</div>
            </div>
            <div class="status-card">
                <h3>🏆 Win Rate</h3>
                <div class="value" id="winRate">0%</div>
                <div style="font-size: 10px; color: #ccc; margin-top: 4px;">Success ratio</div>
            </div>
            <div class="status-card">
                <h3>📊 Total Trades</h3>
                <div class="value" id="totalTrades">0</div>
                <div style="font-size: 10px; color: #ccc; margin-top: 4px;">All-time count</div>
            </div>
            <div class="status-card">
                <h3>⚡ Performance</h3>
                <div class="value" id="performanceScore">A+</div>
                <div style="font-size: 10px; color: #ccc; margin-top: 4px;">Bot efficiency</div>
            </div>
            <div class="status-card">
                <h3>🔒 Security</h3>
                <div class="value" id="securityStatus">🛡️</div>
                <div style="font-size: 10px; color: #ccc; margin-top: 4px;">Wallet secured</div>
            </div>
        </div>

        <!-- Button Management Row -->
        <div class="button-row" style="margin-bottom: 0px !important; padding-bottom: 0px !important;">
            <div class="button-section">
                <h4>🤖 Bot Management</h4>
                <div class="button-group">
                    <button class="start-btn" onclick="startBot()">▶️ START BOT</button>
                    <button class="stop-btn" onclick="stopBot()">⏹️ STOP BOT</button>
                    <button class="config-btn" onclick="openConfig()">⚙️ CONFIGURE</button>
                    <button class="config-btn" onclick="connectWallet()" id="walletBtn">🔗 CONNECT WALLET</button>
                </div>
            </div>

            <div class="button-section">
                <h4>💼 Portfolio Management</h4>
                <div class="button-group">
                    <button onclick="refreshAllBalances()" class="start-btn" style="background: #2196F3;">🔄 REFRESH BALANCES</button>
                    <button onclick="clearAllData()" class="start-btn" style="background: #f44336;">🗑️ CLEAR DATA</button>
                </div>
            </div>
        </div>
        <!-- Trading Logs and Balances Row -->
        <div class="trading-grid" style="margin-top: 0px !important; padding-top: 0px !important; margin-bottom: 30px !important; padding-bottom: 0px !important;">
            <div class="panel" style="margin-top: 0px !important; padding-top: 0px !important;">
                <h3>📋 Logs</h3>
                <div class="tab-container">
                    <div class="tab-buttons">
                        <button class="tab-button active" onclick="switchTab('activity')">📝 Activity Log</button>
                        <button class="tab-button" onclick="switchTab('trading')">📊 Trading Log</button>
                        <button class="tab-button" onclick="switchTab('history')">🔗 TX History</button>
                        <button class="tab-button" onclick="switchTab('debug')">🔍 Debug Analysis</button>
                    </div>
                    <div class="tab-content">
                        <div id="activity-tab" class="tab-panel active">
                            <div class="log" id="tradingLog">
                                <div class="log-entry log-info">Bot initialized. Ready to start trading!</div>
                            </div>
                        </div>
                        <div id="debug-tab" class="tab-panel">
                            <div class="log" id="debugLog">
                                <div class="log-entry log-info">Debug analysis will appear here...</div>
                            </div>
                        </div>
                        <div id="trading-tab" class="tab-panel">
                            <div class="log" id="swapsLog">
                                <div class="log-entry log-info">No swaps yet. Start trading to see your activity!</div>
                            </div>
                        </div>
                        <div id="history-tab" class="tab-panel">
                            <div class="log" id="transactionHistory">
                                <div class="log-entry log-info">Transaction history will appear here...</div>
                            </div>
                            <div style="margin-top: 10px; text-align: center;">
                                <button onclick="cleanupTransactionHistory()" style="background: #ff9800; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">🧹 Clean Up</button>
                                <button onclick="clearTransactionHistory()" style="background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">🗑️ Clear All</button>
                                <button onclick="exportTransactionHistory()" style="background: #4caf50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">📥 Export</button>
                                <button onclick="resetTradingStats()" style="background: #9c27b0; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">📊 Reset Stats</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

        <!-- Spacer to ensure separation between logs and bottom panels -->
        <div style="height: 20px; width: 100%; background: transparent; margin: 0; padding: 0;"></div>

        <!-- Bottom Panels Container - 2x3 Grid Layout -->
        <div class="bottom-panels-container" style="margin-top: 30px !important; padding-top: 15px !important;">
            <!-- Top Left: Market Data -->
            <div class="panel">
                <h3>📈 Market Data</h3>
                <div class="market-data" id="marketData">
                    <div class="market-item">
                        <span class="token-name">GALA/USD</span>
                        <span class="price">$0.0176</span>
                        <span class="change positive">+2.3%</span>
                    </div>
                    <div class="market-item">
                        <span class="token-name">FILM/USD</span>
                        <span class="price">$0.0095</span>
                        <span class="change negative">-1.2%</span>
                </div>
                    <div class="market-item">
                        <span class="token-name">GTON/USD</span>
                        <span class="price">$0.0175</span>
                        <span class="change positive">+0.8%</span>
                    </div>
                    <div class="market-item">
                        <span class="token-name">ETIME/USD</span>
                        <span class="price">$0.0052</span>
                        <span class="change positive">+5.1%</span>
                    </div>
                    <div class="market-item">
                        <span class="token-name">GUSDC/USD</span>
                        <span class="price">$1.0004</span>
                        <span class="change positive">+0.04%</span>
                    </div>
            </div>
        </div>

            <!-- Top Center: Market Analysis -->
            <div class="panel">
                <h3>📊 Market Analysis</h3>
                <div class="token-list" id="tokenList">
                    <div class="token-item">
                        <div class="token-name">🔺 ETIME → GOSMI → GUSDC → ETIME</div>
                        <div class="token-price">+0.001%</div>
                        <div class="token-change positive">Active</div>
                    </div>
                    <div class="token-item">
                        <div class="token-name">🔺 GOSMI → ETIME → GUSDC → GOSMI</div>
                        <div class="token-price">+0.001%</div>
                        <div class="token-change positive">Active</div>
                    </div>
                    <div class="token-item">
                        <div class="token-name">🔺 ETIME → GOSMI → GMUSIC → ETIME</div>
                        <div class="token-price">+0.001%</div>
                        <div class="token-change positive">Active</div>
                    </div>
                    <div class="token-item">
                        <div class="token-name">🔺 GOSMI → ETIME → GMUSIC → GOSMI</div>
                        <div class="token-price">+0.001%</div>
                        <div class="token-change positive">Active</div>
                    </div>
                    <div class="token-item">
                        <div class="token-name">🔺 ETIME → FILM → GUSDC → ETIME</div>
                        <div class="token-price">+0.001%</div>
                        <div class="token-change positive">Active</div>
                    </div>
                </div>
            </div>

            <!-- Top Right: Trading Signals -->
            <div class="panel">
                <h3>🎯 Trading Signals</h3>
                <div class="token-list" id="tradingSignals">
                    <div class="token-item">
                        <div class="token-name">🟢 GALA - Strong Buy</div>
                        <div class="token-price">RSI: 35</div>
                        <div class="token-change positive">Bullish</div>
                    </div>
                    <div class="token-item">
                        <div class="token-name">🟡 FILM - Hold</div>
                        <div class="token-price">RSI: 52</div>
                        <div class="token-change neutral">Neutral</div>
                    </div>
                    <div class="token-item">
                        <div class="token-name">🟢 ETIME - Strong Buy</div>
                        <div class="token-price">RSI: 28</div>
                        <div class="token-change positive">Bullish</div>
                    </div>
                    <div class="token-item">
                        <div class="token-name">🔴 GTON - Sell</div>
                        <div class="token-price">RSI: 78</div>
                        <div class="token-change negative">Bearish</div>
                    </div>
                    <div class="token-item">
                        <div class="token-name">🟡 GUSDC - Hold</div>
                        <div class="token-price">RSI: 48</div>
                        <div class="token-change neutral">Neutral</div>
                    </div>
                </div>
            </div>

            <!-- Bottom Left: Trade Statistics -->
            <div class="panel">
                <h3>📊 Trade Statistics</h3>
                <div class="portfolio-summary" id="tradeStats" style="background: rgba(255, 255, 255, 0.1); padding: 10px; border-radius: 6px; width: 100%; height: 100%; flex: 1; overflow-y: auto;">
                    <div class="summary-item" style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.2);">
                        <span class="summary-label" style="color: #ffd700; font-weight: 600;">Total Swaps:</span>
                        <span class="summary-value" id="totalSwaps" style="color: #ffffff; font-weight: bold;">0</span>
                    </div>
                    <div class="summary-item" style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.2);">
                        <span class="summary-label" style="color: #ffd700; font-weight: 600;">Successful Swaps:</span>
                        <span class="summary-value" id="successfulSwaps" style="color: #ffffff; font-weight: bold;">0</span>
                    </div>
                    <div class="summary-item" style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.2);">
                        <span class="summary-label" style="color: #ffd700; font-weight: 600;">Failed Swaps:</span>
                        <span class="summary-value" id="failedSwaps" style="color: #ffffff; font-weight: bold;">0</span>
                    </div>
                    <div class="summary-item" style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.2);">
                        <span class="summary-label" style="color: #ffd700; font-weight: 600;">Success Rate:</span>
                        <span class="summary-value" id="swapSuccessRate" style="color: #ffffff; font-weight: bold;">0%</span>
                    </div>
                    <div class="summary-item" style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.2);">
                        <span class="summary-label" style="color: #ffd700; font-weight: 600;">Avg Profit per Trade:</span>
                        <span class="summary-value" id="avgProfit" style="color: #ffffff; font-weight: bold;">$0.00</span>
                    </div>
                    <div class="summary-item" style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.2);">
                        <span class="summary-label" style="color: #ffd700; font-weight: 600;">Best Trade:</span>
                        <span class="summary-value" id="bestTrade" style="color: #ffffff; font-weight: bold;">$0.00</span>
                    </div>
                    <div class="summary-item" style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.2);">
                        <span class="summary-label" style="color: #ffd700; font-weight: 600;">Worst Trade:</span>
                        <span class="summary-value" id="worstTrade" style="color: #ffffff; font-weight: bold;">$0.00</span>
                    </div>
                    <div class="summary-item" style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.2);">
                        <span class="summary-label" style="color: #ffd700; font-weight: 600;">Total Volume:</span>
                        <span class="summary-value" id="totalVolume" style="color: #ffffff; font-weight: bold;">$0.00</span>
                    </div>
                    <div class="summary-item" style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.2);">
                        <span class="summary-label" style="color: #ffd700; font-weight: 600;">Arbitrage Trades:</span>
                        <span class="summary-value" id="arbitrageTrades" style="color: #ffffff; font-weight: bold;">0</span>
                    </div>
                    <div class="summary-item" style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.2);">
                        <span class="summary-label" style="color: #ffd700; font-weight: 600;">Arbitrage Profit:</span>
                        <span class="summary-value" id="arbitrageProfit" style="color: #ffffff; font-weight: bold;">$0.00</span>
                    </div>
                    <div class="summary-item" style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.2);">
                        <span class="summary-label" style="color: #ffd700; font-weight: 600;">Active Opportunities:</span>
                        <span class="summary-value" id="activeOpportunities" style="color: #ffffff; font-weight: bold;">10</span>
                    </div>
                    <div class="summary-item" style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.2);">
                        <span class="summary-label" style="color: #ffd700; font-weight: 600;">Last Trade Time:</span>
                        <span class="summary-value" id="lastTradeTime" style="color: #ffffff; font-weight: bold;">Never</span>
                    </div>
                    <div class="summary-item" style="display: flex; justify-content: space-between; padding: 4px 0;">
                        <span class="summary-label" style="color: #ffd700; font-weight: 600;">Bot Uptime:</span>
                        <span class="summary-value" id="botUptime" style="color: #ffffff; font-weight: bold;">0h 0m</span>
                    </div>
                </div>
            </div>

            <!-- Bottom Center: Performance & Risk -->
            <div class="panel">
                <h3>⚡ Performance & Risk</h3>
                <div class="portfolio-summary" id="performanceMetrics" style="background: rgba(255, 255, 255, 0.1); padding: 10px; border-radius: 6px; width: 100%; height: 100%; flex: 1; overflow-y: auto;">
                    <div class="summary-item" style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.2);">
                        <span class="summary-label" style="color: #ffd700; font-weight: 600;">Scan Frequency:</span>
                        <span class="summary-value" style="color: #ffffff; font-weight: bold;">10s</span>
                    </div>
                    <div class="summary-item" style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.2);">
                        <span class="summary-label" style="color: #ffd700; font-weight: 600;">Avg Response Time:</span>
                        <span class="summary-value" style="color: #ffffff; font-weight: bold;">150ms</span>
                    </div>
                    <div class="summary-item" style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.2);">
                        <span class="summary-label" style="color: #ffd700; font-weight: 600;">API Calls/min:</span>
                        <span class="summary-value" style="color: #ffffff; font-weight: bold;">6</span>
                    </div>
                    <div class="summary-item" style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.2);">
                        <span class="summary-label" style="color: #ffd700; font-weight: 600;">Error Rate:</span>
                        <span class="summary-value" style="color: #ffffff; font-weight: bold;">0%</span>
                    </div>
                    <div class="summary-item" style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.2);">
                        <span class="summary-label" style="color: #ffd700; font-weight: 600;">Max Position Size:</span>
                        <span class="summary-value" style="color: #ffffff; font-weight: bold;">25 GALA</span>
                    </div>
                    <div class="summary-item" style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.2);">
                        <span class="summary-label" style="color: #ffd700; font-weight: 600;">Stop Loss:</span>
                        <span class="summary-value" style="color: #ffffff; font-weight: bold;">5%</span>
                    </div>
                    <div class="summary-item" style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.2);">
                        <span class="summary-label" style="color: #ffd700; font-weight: 600;">Take Profit:</span>
                        <span class="summary-value" style="color: #ffffff; font-weight: bold;">10%</span>
                    </div>
                    <div class="summary-item" style="display: flex; justify-content: space-between; padding: 4px 0;">
                        <span class="summary-label" style="color: #ffd700; font-weight: 600;">Risk Score:</span>
                        <span class="summary-value" style="color: #ffffff; font-weight: bold;">Low</span>
                    </div>
                </div>
            </div>

            <!-- Bottom Right: Token Balances & Portfolio -->
            <div class="panel">
                <h3>💰 Token Balances & Portfolio</h3>
                
                <!-- Balance Update Timer -->
                <div id="balance-update-timer" style="font-size: 11px; color: #00ff88; margin: 2px 0; text-align: center; padding: 2px; background: rgba(0,255,136,0.1); border-radius: 3px;">
                    ⏱️ Last updated: Never
                </div>
                
                <div class="balance-list" id="balanceList">
                    <div class="token-item">
                        <div class="token-name">Loading balances...</div>
                        <div class="token-price">-</div>
                        <div class="token-change">-</div>
                    </div>
                </div>

                <!-- Portfolio Summary Section -->
                <div class="portfolio-summary-section">
                    <h4>📈 Portfolio Summary</h4>
                    <div class="portfolio-summary" id="portfolioSummary">
                    <div class="summary-item">
                            <span class="summary-label">Total Value:</span>
                            <span class="summary-value" id="totalValue">$0.00</span>
                    </div>
                    <div class="summary-item">
                            <span class="summary-label">GALA Value:</span>
                            <span class="summary-value" id="galaValue">$0.00</span>
                    </div>
                    <div class="summary-item">
                            <span class="summary-label">Other Tokens:</span>
                            <span class="summary-value" id="otherTokensValue">$0.00</span>
                    </div>
                    <div class="summary-item">
                            <span class="summary-label">Unrealized P&L:</span>
                            <span class="summary-value" id="unrealizedPnL">$0.00</span>
                    </div>
                </div>
            </div>
        </div>

        </div>

    </div>

    <!-- Configuration Panel -->
    <div class="config-panel" id="configPanel">
        <div class="config-content">
            <button class="close-btn" onclick="closeConfig()">×</button>
            <h3>Bot Configuration</h3>
            
            <!-- Current Mode Display -->
            <div class="form-group" style="background: rgba(0,0,0,0.1); padding: 10px; border-radius: 5px; margin-bottom: 15px;">
                <h4 style="margin: 0 0 10px 0; color: #333;">Current Trading Mode</h4>
                <div id="currentModeDisplay" style="font-size: 16px; font-weight: bold; padding: 8px; border-radius: 4px; text-align: center;">
                    🛡️ CONSERVATIVE MODE
                </div>
                <small style="color: #666; display: block; margin-top: 5px; text-align: center;">
                    Safe & Steady Trading
                </small>
            </div>
            
            <!-- Mode Selection -->
            <div class="form-group">
                <label for="tradingModeSelect">Trading Mode:</label>
                <select id="tradingModeSelect" onchange="setTradingMode(this.value)">
                    <option value="conservative">🛡️ Conservative - Safe & Steady</option>
                    <option value="tradecap">🔒 Trade Cap - Small Testing</option>
                    <option value="competition">🏆 Competition - High-Frequency</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="riskLevel">Risk Level:</label>
                <select id="riskLevel">
                    <option value="low">Low (Conservative)</option>
                    <option value="medium" selected>Medium (Balanced)</option>
                    <option value="high">High (Aggressive)</option>
                </select>
            </div>

            <div class="form-group">
                <label for="maxPositionSize">Max Position Size (% of portfolio):</label>
                <input type="number" id="maxPositionSize" value="20" min="5" max="50">
            </div>

            <div class="form-group">
                <label for="profitTarget">Profit Target (%):</label>
                <input type="number" id="profitTarget" value="5" min="1" max="50">
            </div>

            <div class="form-group">
                <label for="stopLoss">Stop Loss (%):</label>
                <input type="number" id="stopLoss" value="3" min="1" max="20">
            </div>

            <div class="form-group">
                <label for="scanInterval">Scan Interval (seconds):</label>
                <input type="number" id="scanInterval" value="10" min="1" max="60">
                <small style="color: #888;">Conservative: 10s | Trade Cap: 5s | Competition: 1s</small>
            </div>
            
            <!-- Conservative Mode Settings -->
            <div class="form-group" id="conservativeSettings" style="display: block;">
                <h4 style="color: #4caf50; margin: 10px 0;">🛡️ Conservative Mode Settings</h4>
                
                <label for="conservativeArbitrageThreshold">Arbitrage Threshold (%):</label>
                <input type="number" id="conservativeArbitrageThreshold" value="3" min="0.1" max="10" step="0.1">
                <small style="color: #888;">High threshold for safety (3% default)</small>
                
                <label for="conservativeBuyThreshold">Buy Threshold:</label>
                <input type="number" id="conservativeBuyThreshold" value="0.7" min="0.1" max="1" step="0.1">
                <small style="color: #888;">High buy threshold for conservative trading (0.7 default)</small>
                
                <label for="conservativeSellThreshold">Sell Threshold:</label>
                <input type="number" id="conservativeSellThreshold" value="0.5" min="0.1" max="1" step="0.1">
                <small style="color: #888;">High sell threshold for conservative trading (0.5 default)</small>
            </div>
            
            <div class="form-group" id="competitionSettings" style="display: none;">
                <h4 style="color: #9c27b0; margin: 10px 0;">🏆 Competition Mode Settings</h4>
                
                <label for="maxTradesPerSecond">Max Trades Per Second:</label>
                <input type="number" id="maxTradesPerSecond" value="5" min="1" max="20">
                <small style="color: #888;">Conservative: 1/sec | Trade Cap: 2/sec | Competition: 5/sec</small>
                
                <label for="concurrentTrades">Concurrent Trades:</label>
                <input type="number" id="concurrentTrades" value="3" min="1" max="10">
                <small style="color: #888;">Conservative: 1 | Trade Cap: 1 | Competition: 3</small>
                
                <label for="arbitrageThreshold">Arbitrage Threshold (%):</label>
                <input type="number" id="arbitrageThreshold" value="1" min="0.1" max="5" step="0.1">
                <small style="color: #888;">Conservative: 3% | Trade Cap: 2% | Competition: 1%</small>
                
                <label for="competitionBuyThreshold">Buy Threshold:</label>
                <input type="number" id="competitionBuyThreshold" value="0.5" min="0.1" max="1" step="0.1">
                <small style="color: #888;">Lower buy threshold for more opportunities (0.5 default)</small>
                
                <label for="competitionSellThreshold">Sell Threshold:</label>
                <input type="number" id="competitionSellThreshold" value="0.3" min="0.1" max="1" step="0.1">
                <small style="color: #888;">Lower sell threshold for more opportunities (0.3 default)</small>
            </div>
            
            <div class="form-group" id="tradeCapSettings" style="display: none;">
                <h4 style="color: #ff9800; margin: 10px 0;">🔒 Trade Cap Mode Settings</h4>
                
                <label for="maxTradeAmount">Max Trade Amount (GALA):</label>
                <input type="number" id="maxTradeAmount" value="25" min="5" max="50">
                <small style="color: #888;">Maximum GALA per trade (5-25 range)</small>
                
                <label for="tradeCapArbitrageThreshold">Arbitrage Threshold (%):</label>
                <input type="number" id="tradeCapArbitrageThreshold" value="2" min="0.1" max="5" step="0.1">
                <small style="color: #888;">Medium threshold for testing (2% default)</small>
                
                <label for="tradeCapBuyThreshold">Buy Threshold:</label>
                <input type="number" id="tradeCapBuyThreshold" value="0.6" min="0.1" max="1" step="0.1">
                <small style="color: #888;">Medium buy threshold (0.6 default)</small>
                
                <label for="tradeCapSellThreshold">Sell Threshold:</label>
                <input type="number" id="tradeCapSellThreshold" value="0.4" min="0.1" max="1" step="0.1">
                <small style="color: #888;">Medium sell threshold (0.4 default)</small>
            </div>

            <button class="start-btn" onclick="saveConfig()">Save Configuration</button>
        </div>
    </div>

    <script>
        // Immediate test to see if JavaScript is working
        console.log('JavaScript is loading...');
        alert('Script started loading!');
        
        // Test if we can define a simple function
        function testScriptLoading() {
            alert('Script is loading correctly!');
        }
        
        // Make it globally available immediately
        window.testScriptLoading = testScriptLoading;
        
        // Function to enforce log heights after content updates
        function enforceLogHeights() {
            const logContainers = ['tradingLog', 'swapsLog', 'debugLog', 'transactionHistory'];
            logContainers.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.style.height = '600px';
                    element.style.minHeight = '600px';
                    element.style.maxHeight = '600px';
                    element.style.flex = '1';
                }
            });
            
            const logsPanel6 = document.querySelector('.trading-grid .panel:first-child');
            if (logsPanel6) {
                logsPanel6.style.height = '700px';
                logsPanel6.style.minHeight = '700px';
                logsPanel6.style.maxHeight = '700px';
                logsPanel6.style.display = 'flex';
                logsPanel6.style.flexDirection = 'column';
                logsPanel6.style.marginTop = '0px';
                logsPanel6.style.paddingTop = '0px';
            }
            
            // Force trading grid to have proper bottom spacing
            const tradingGrid = document.querySelector('.trading-grid');
            if (tradingGrid) {
                tradingGrid.style.marginTop = '0px';
                tradingGrid.style.paddingTop = '0px';
                tradingGrid.style.marginBottom = '25px';
                tradingGrid.style.paddingBottom = '0px';
            }
            
            // Force bottom panels to have proper top spacing
            const bottomPanels = document.querySelector('.bottom-panels-container');
            if (bottomPanels) {
                bottomPanels.style.marginTop = '25px';
                bottomPanels.style.paddingTop = '15px';
            }
            
            // Force button row to have no bottom spacing
            const buttonRow = document.querySelector('.button-row');
            if (buttonRow) {
                buttonRow.style.marginBottom = '0px';
                buttonRow.style.paddingBottom = '0px';
            }
            
            const tabContainer = document.querySelector('.tab-container');
            if (tabContainer) {
                tabContainer.style.height = '650px';
                tabContainer.style.minHeight = '650px';
                tabContainer.style.maxHeight = '650px';
                tabContainer.style.flex = '1';
            }
            
            const tabContent = document.querySelector('.tab-content');
            if (tabContent) {
                tabContent.style.flex = '1';
                tabContent.style.display = 'flex';
                tabContent.style.flexDirection = 'column';
            }
            
            const activeTab = document.querySelector('.tab-panel.active');
            if (activeTab) {
                activeTab.style.flex = '1';
                activeTab.style.display = 'flex';
                activeTab.style.flexDirection = 'column';
            }
            
            // Auto-scroll logs to bottom
            scrollLogsToBottom();
        }
        
        // Function to scroll logs to bottom
        function scrollLogsToBottom() {
            const logContainers = ['tradingLog', 'swapsLog', 'debugLog', 'transactionHistory'];
            logContainers.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.scrollTop = element.scrollHeight;
                }
            });
        }
        
        // Enforce heights immediately when DOM is ready
        // Check server status
        async function checkServerStatus() {
            try {
                // Add timeout to prevent hanging
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout
                
                const response = await fetch('http://localhost:3000/api/health', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (response.ok) {
                    const data = await response.json();
                    updateServerStatus('success', `🟢 Server Connected: ${data.status}`);
                    logMessage('✅ Server connection successful', 'success');
                } else {
                    updateServerStatus('error', '🔴 Server Error: Connection failed');
                    logMessage('❌ Server connection failed', 'error');
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    updateServerStatus('error', '🔴 Server Timeout: Taking too long to respond');
                    logMessage('⏰ Server timeout - check if server is running', 'error');
                } else {
                    updateServerStatus('error', '🔴 Server Offline: localhost:3000 not responding');
                    logMessage('❌ Server offline - make sure to run: node real-trading-server-clean.js', 'error');
                }
            }
        }

        // Update server status display
        function updateServerStatus(status, message) {
            const statusElement = document.getElementById('serverStatus');
            if (statusElement) {
                if (status === 'success') {
                    statusElement.style.color = '#4caf50';
                    statusElement.style.background = 'rgba(76, 175, 80, 0.1)';
                    statusElement.style.borderColor = '#4caf50';
                } else {
                    statusElement.style.color = '#f44336';
                    statusElement.style.background = 'rgba(244, 67, 54, 0.1)';
                    statusElement.style.borderColor = '#f44336';
                }
                statusElement.textContent = message;
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            console.log('🚀 DOMContentLoaded event fired - starting initialization');
            
            // Check server status on page load (non-blocking)
            checkServerStatus().catch(error => {
                console.log('Server status check failed:', error);
            });
            
            // Clear test tokens from localStorage on page load
            const savedBalances = localStorage.getItem('lastKnownBalances');
            if (savedBalances) {
                try {
                    const balances = JSON.parse(savedBalances);
                    const cleanedBalances = {};
                    Object.keys(balances).forEach(key => {
                        if (!key.includes('DEXT') && !key.includes('none')) {
                            cleanedBalances[key] = balances[key];
                        }
                    });
                    localStorage.setItem('lastKnownBalances', JSON.stringify(cleanedBalances));
                    console.log('🧹 Cleaned test tokens from localStorage');
                } catch (e) {
                    console.log('⚠️ Error cleaning test tokens:', e);
                }
            }
            
            // Load all persistent data
            loadTransactionHistory();
            loadTradingStats();
            loadPortfolioData();
            loadBotConfig();
            
            // Load private key from storage on page load
            loadPrivateKey();
            
            // Update wallet status UI after loading
            updateWalletStatus();
            
            // Initialize balance update timer if we have saved data
            const savedUpdateTime = localStorage.getItem('lastSuccessfulBalanceUpdate');
            if (savedUpdateTime) {
                lastSuccessfulBalanceUpdate = new Date(savedUpdateTime);
                startBalanceUpdateTimer();
            } else {
                // Start timer with current time if no saved data
                lastSuccessfulBalanceUpdate = new Date();
                startBalanceUpdateTimer();
            }
            
            // Initialize with known balances if no saved data exists
            const savedBalancesCheck = localStorage.getItem('lastKnownBalances');
            if (!savedBalancesCheck && walletConnected) {
                // Set initial known balances based on your actual wallet
                const initialBalances = {
                    'GALA|Unit|none|none': 1459.64,
                    'GUSDC|Unit|none|none': 0.67,
                    'FILM|Unit|none|none': 0.97,
                    'GMUSIC|Unit|none|none': 0.06,
                    'ETIME|Unit|none|none': 0,
                    'GTON|Unit|none|none': 0,
                    'GOSMI|Unit|none|none': 0
                };
                
                localStorage.setItem('lastKnownBalances', JSON.stringify(initialBalances));
                Object.assign(tokenBalances, initialBalances);
                galaBalance = 1459.64;
                
                // Set initial update time
                lastSuccessfulBalanceUpdate = new Date();
                localStorage.setItem('lastSuccessfulBalanceUpdate', lastSuccessfulBalanceUpdate.toISOString());
                startBalanceUpdateTimer();
                
                // Schedule first auto-refresh in 30 seconds
                balanceSuccessTimeout = setTimeout(() => {
                    logMessage(`🔄 Auto-refreshing balances (30s interval)...`, 'info');
                    loadAllTokenBalances();
                }, balanceSuccessDelay);
                
                logMessage('📋 Initialized with known balances', 'info');
            }
            
            setTimeout(enforceLogHeights, 100);
            setTimeout(enforceLogHeights, 500);
            setTimeout(enforceLogHeights, 1000);
            
            // Ensure swap stats are updated
            setTimeout(updateSwapStats, 100);
            setTimeout(updateSwapStats, 500);
            
            // Watch for DOM changes and enforce heights
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'childList' || mutation.type === 'attributes') {
                        setTimeout(enforceLogHeights, 10);
                    }
                });
            });
            
            // Start observing
            const logsPanel2 = document.querySelector('.trading-grid .panel:first-child');
            if (logsPanel2) {
                observer.observe(logsPanel2, {
                    childList: true,
                    subtree: true,
                    attributes: true,
                    attributeFilter: ['style', 'class']
                });
            }
            
            // Force the right panel to be ultra-compact
            const rightPanel = document.querySelector('.trading-grid .panel:last-child');
            if (rightPanel) {
                rightPanel.style.height = '100%';
                rightPanel.style.minHeight = '100%';
                rightPanel.style.maxHeight = 'none';
                rightPanel.style.alignSelf = 'stretch';
                rightPanel.style.flexShrink = '1';
                rightPanel.style.flexGrow = '0';
                rightPanel.style.padding = '2px';
                rightPanel.style.margin = '0';
                rightPanel.style.overflow = 'visible';
                rightPanel.style.display = 'inline-block';
                rightPanel.style.width = '100%';
                rightPanel.style.verticalAlign = 'top';
                
                // Ultra-aggressive DOM manipulation
                const allChildren = rightPanel.querySelectorAll('*');
                allChildren.forEach(child => {
                    child.style.margin = '0';
                    child.style.padding = '0';
                    child.style.border = 'none';
                    child.style.lineHeight = '1.1';
                });
                
                // Specific element targeting
                const h3 = rightPanel.querySelector('h3');
                if (h3) {
                    h3.style.margin = '0 0 5px 0';
                    h3.style.padding = '5px 0';
                    h3.style.fontSize = '14px';
                }
                
                const h4 = rightPanel.querySelector('h4');
                if (h4) {
                    h4.style.margin = '5px 0 3px 0';
                    h4.style.padding = '3px 0';
                    h4.style.fontSize = '12px';
                }
                
                const balanceList = rightPanel.querySelector('.balance-list');
                if (balanceList) {
                    balanceList.style.margin = '0';
                    balanceList.style.padding = '0';
                    balanceList.style.height = 'auto';
                    balanceList.style.minHeight = 'auto';
                    balanceList.style.maxHeight = 'none';
                }
                
                const tokenItems = rightPanel.querySelectorAll('.token-item');
                tokenItems.forEach(item => {
                    item.style.margin = '0';
                    item.style.padding = '2px 0';
                    item.style.border = 'none';
                });
                
                const portfolioSummary = rightPanel.querySelector('.portfolio-summary-section');
                if (portfolioSummary) {
                    portfolioSummary.style.margin = '5px 0 0 0';
                    portfolioSummary.style.padding = '0';
                    portfolioSummary.style.border = 'none';
                }
                
                const portfolioSummaryInner = rightPanel.querySelector('.portfolio-summary');
                if (portfolioSummaryInner) {
                    portfolioSummaryInner.style.margin = '0';
                    portfolioSummaryInner.style.padding = '0';
                }
                
                const summaryItems = rightPanel.querySelectorAll('.summary-item');
                summaryItems.forEach(item => {
                    item.style.margin = '0';
                    item.style.padding = '1px 0';
                    item.style.border = 'none';
                });
            }
            
            // Force trading grid to fill full height
            const tradingGrid = document.querySelector('.trading-grid');
            if (tradingGrid) {
                tradingGrid.style.height = '100vh';
                tradingGrid.style.minHeight = '100vh';
                tradingGrid.style.alignItems = 'stretch';
            }
            
            // Force three-panel-grid to fill remaining space
            const threePanelGrid = document.querySelector('.three-panel-grid');
            if (threePanelGrid) {
                threePanelGrid.style.height = 'calc(100vh - 200px)';
                threePanelGrid.style.minHeight = 'calc(100vh - 200px)';
            }
            
            // Force logs section to fill available space
            const logsPanel3 = document.querySelector('.trading-grid .panel:first-child');
            if (logsPanel3) {
                logsPanel3.style.height = 'calc(100vh - 150px)';
                logsPanel3.style.minHeight = 'calc(100vh - 150px)';
                logsPanel3.style.maxHeight = 'calc(100vh - 150px)';
            }
            
            const tabContainer = document.querySelector('.trading-grid .panel:first-child .tab-container');
            if (tabContainer) {
                tabContainer.style.height = 'calc(100vh - 200px)';
                tabContainer.style.minHeight = 'calc(100vh - 200px)';
                tabContainer.style.maxHeight = 'calc(100vh - 200px)';
            }
            
            const logElements = document.querySelectorAll('.trading-grid .panel:first-child .log');
            logElements.forEach(log => {
                log.style.height = 'calc(100vh - 250px)';
                log.style.minHeight = 'calc(100vh - 250px)';
                log.style.maxHeight = 'calc(100vh - 250px)';
            });
            
            // Continuous enforcement every 2 seconds
            setInterval(() => {
                enforceLogHeights();
                
                // Force logs section to fill available space
                const logsPanel4 = document.querySelector('.trading-grid .panel:first-child');
                if (logsPanel4) {
                    logsPanel4.style.height = 'calc(100vh - 150px)';
                    logsPanel4.style.minHeight = 'calc(100vh - 150px)';
                    logsPanel4.style.maxHeight = 'calc(100vh - 150px)';
                }
                
                const tabContainer = document.querySelector('.trading-grid .panel:first-child .tab-container');
                if (tabContainer) {
                    tabContainer.style.height = 'calc(100vh - 200px)';
                    tabContainer.style.minHeight = 'calc(100vh - 200px)';
                    tabContainer.style.maxHeight = 'calc(100vh - 200px)';
                }
                
                const logElements = document.querySelectorAll('.trading-grid .panel:first-child .log');
                logElements.forEach(log => {
                    log.style.height = 'calc(100vh - 250px)';
                    log.style.minHeight = 'calc(100vh - 250px)';
                    log.style.maxHeight = 'calc(100vh - 250px)';
                });
                
                // Also enforce right panel ultra-compactness
                const rightPanel = document.querySelector('.trading-grid .panel:last-child');
                if (rightPanel) {
                    rightPanel.style.height = '100%';
                    rightPanel.style.minHeight = '100%';
                    rightPanel.style.maxHeight = 'none';
                    rightPanel.style.alignSelf = 'stretch';
                    rightPanel.style.flexShrink = '1';
                    rightPanel.style.flexGrow = '0';
                    rightPanel.style.padding = '2px';
                    rightPanel.style.margin = '0';
                    rightPanel.style.overflow = 'visible';
                    rightPanel.style.display = 'inline-block';
                    rightPanel.style.width = '100%';
                    rightPanel.style.verticalAlign = 'top';
                    
                    // Ultra-aggressive DOM manipulation
                    const allChildren = rightPanel.querySelectorAll('*');
                    allChildren.forEach(child => {
                        child.style.margin = '0';
                        child.style.padding = '0';
                        child.style.border = 'none';
                        child.style.lineHeight = '1.1';
                    });
                    
                    // Specific element targeting
                    const h3 = rightPanel.querySelector('h3');
                    if (h3) {
                        h3.style.margin = '0 0 5px 0';
                        h3.style.padding = '5px 0';
                        h3.style.fontSize = '14px';
                    }
                    
                    const h4 = rightPanel.querySelector('h4');
                    if (h4) {
                        h4.style.margin = '5px 0 3px 0';
                        h4.style.padding = '3px 0';
                        h4.style.fontSize = '12px';
                    }
                    
                    const balanceList = rightPanel.querySelector('.balance-list');
                    if (balanceList) {
                        balanceList.style.margin = '0';
                        balanceList.style.padding = '0';
                        balanceList.style.height = 'auto';
                        balanceList.style.minHeight = 'auto';
                        balanceList.style.maxHeight = 'none';
                    }
                    
                    const tokenItems = rightPanel.querySelectorAll('.token-item');
                    tokenItems.forEach(item => {
                        item.style.margin = '0';
                        item.style.padding = '2px 0';
                        item.style.border = 'none';
                    });
                    
                    const portfolioSummary = rightPanel.querySelector('.portfolio-summary-section');
                    if (portfolioSummary) {
                        portfolioSummary.style.margin = '5px 0 0 0';
                        portfolioSummary.style.padding = '0';
                        portfolioSummary.style.border = 'none';
                    }
                    
                    const portfolioSummaryInner = rightPanel.querySelector('.portfolio-summary');
                    if (portfolioSummaryInner) {
                        portfolioSummaryInner.style.margin = '0';
                        portfolioSummaryInner.style.padding = '0';
                    }
                    
                    const summaryItems = rightPanel.querySelectorAll('.summary-item');
                    summaryItems.forEach(item => {
                        item.style.margin = '0';
                        item.style.padding = '1px 0';
                        item.style.border = 'none';
                    });
                }
            }, 2000);
            
            // Initialize the bot
            console.log('🎯 About to call initBot()');
            initBot();
            console.log('✅ initBot() completed');
            
            // Debug: Check if functions are accessible
            console.log('🔍 Button functions check:');
            console.log('startBot:', typeof startBot);
            console.log('stopBot:', typeof stopBot);
            console.log('connectWallet:', typeof connectWallet);
            console.log('setPrivateKey:', typeof setPrivateKey);
            console.log('clearPrivateKey:', typeof clearPrivateKey);
            console.log('openConfig:', typeof openConfig);
            console.log('disconnectWallet:', typeof disconnectWallet);
            
            // Test button click handlers
            setTimeout(() => {
                const startBtn = document.querySelector('button[onclick="startBot()"]');
                const stopBtn = document.querySelector('button[onclick="stopBot()"]');
                const connectBtn = document.querySelector('button[onclick="connectWallet()"]');
                
                console.log('🔍 Button elements found:');
                console.log('Start button:', startBtn);
                console.log('Stop button:', stopBtn);
                console.log('Connect button:', connectBtn);
                
                if (startBtn) {
                    startBtn.addEventListener('click', (e) => {
                        console.log('✅ Start button clicked via addEventListener');
                        startBot();
                    });
                }
                
                if (stopBtn) {
                    stopBtn.addEventListener('click', (e) => {
                        console.log('✅ Stop button clicked via addEventListener');
                        stopBot();
                    });
                }
                
                if (connectBtn) {
                    connectBtn.addEventListener('click', (e) => {
                        console.log('✅ Connect button clicked via addEventListener');
                        connectWallet();
                    });
                }
            }, 1000);
        });
        

        // Function to verify the last transaction manually

        // Global variables
        let botRunning = false;
        let botStartTime = null;
        let scanInterval = null;
        let portfolioValue = 0; // Will be set when wallet connects
        let tradeCapMode = true; // Enable trade cap for small trades
        let competitionMode = true; // Enable competition mode for maximum opportunities
        let totalProfit = 0;
        let activeTrades = 0;
        let tokenPrices = {};
        let priceHistory = {};
        let tradingPairs = [];
        let totalTrades = 0;
        
        // Enhanced statistics using SDK API calls
        let marketDataCollector = new MarketDataCollector();
        let marketAnalysisEngine = new MarketAnalysisEngine(marketDataCollector);
        let tradingSignalsGenerator = new TradingSignalsGenerator(marketAnalysisEngine);
        let tradeStatisticsTracker = new TradeStatisticsTracker();
        let performanceRiskAnalyzer = new PerformanceRiskAnalyzer(tradeStatisticsTracker);
        let portfolioManager = new PortfolioManager();
        
        // Balance retry system
        let lastKnownBalances = {};
        let balanceRetryCount = 0;
        let maxBalanceRetries = 3;
        let balanceRetryDelay = 5000; // 5 seconds after fail
        let balanceSuccessDelay = 30000; // 30 seconds after success
        let lastBalanceFetchTime = 0;
        let balanceFetchCooldown = 2000; // 2 seconds minimum between requests
        let balanceRetryTimeout = null;
        let balanceSuccessTimeout = null; // Timer for successful refresh
        let lastSuccessfulBalanceUpdate = null; // Timestamp of last successful balance fetch
        let balanceUpdateTimer = null; // Timer for displaying time since last update

        // Legacy trading statistics for backward compatibility
        let tradingStats = {
            totalTrades: 0,
            totalProfit: 0,
            successfulTrades: 0,
            failedTrades: 0,
            totalVolume: 0,
            bestTrade: 0,
            worstTrade: 0,
            sessionStartTime: null,
            lastResetTime: null
        };
        let winningTrades = 0;
        let tradeHistory = [];
        
        // High-frequency trading controls
        let tradeQueue = [];
        let executingTrades = 0;
        let lastTradeTime = 0;
        let tradesThisSecond = 0;
        let currentSecond = Math.floor(Date.now() / 1000);
        
        // Wallet variables
        let walletConnected = false;
        let walletAddress = null;
        
        // Persistent Transaction History
        let transactionHistory = [];
        
        // Load transaction history from localStorage
        function loadTransactionHistory() {
            try {
                const saved = localStorage.getItem('galaswap_tx_history');
                if (saved) {
                    transactionHistory = JSON.parse(saved);
                    // Clean up any non-real transactions on load
                    cleanupTransactionHistory();
                }
            } catch (error) {
                console.error('Failed to load transaction history:', error);
                transactionHistory = [];
            }
        }
        
        // Load trading statistics from localStorage
        function loadTradingStats() {
            try {
                const saved = localStorage.getItem('galaswap_trading_stats');
                if (saved) {
                    const savedStats = JSON.parse(saved);
                    tradingStats = { ...tradingStats, ...savedStats };
                    
                    // Update UI variables
                    totalTrades = tradingStats.totalTrades;
                    totalProfit = tradingStats.totalProfit;
                    
                    console.log('📊 Loaded trading statistics:', tradingStats);
                }
            } catch (error) {
                console.error('Failed to load trading statistics:', error);
                // Initialize with current session
                tradingStats.sessionStartTime = new Date().toISOString();
            }
        }
        
        // Save trading statistics to localStorage
        function saveTradingStats() {
            try {
                // Update stats object with current values
                tradingStats.totalTrades = totalTrades;
                tradingStats.totalProfit = totalProfit;
                tradingStats.sessionStartTime = tradingStats.sessionStartTime || new Date().toISOString();
                
                localStorage.setItem('galaswap_trading_stats', JSON.stringify(tradingStats));
                console.log('💾 Saved trading statistics:', tradingStats);
            } catch (error) {
                console.error('Failed to save trading statistics:', error);
            }
        }
        
        // Load portfolio data from localStorage
        function loadPortfolioData() {
            try {
                const saved = localStorage.getItem('galaswap_portfolio_data');
                if (saved) {
                    const portfolioData = JSON.parse(saved);
                    
                    // Restore portfolio value
                    if (portfolioData.portfolioValue) {
                        portfolioValue = portfolioData.portfolioValue;
                    }
                    
                    // Restore token balances if available
                    if (portfolioData.tokenBalances) {
                        Object.assign(tokenBalances, portfolioData.tokenBalances);
                    }
                    
                    console.log('💼 Loaded portfolio data:', portfolioData);
                }
            } catch (error) {
                console.error('Failed to load portfolio data:', error);
            }
        }
        
        // Save portfolio data to localStorage
        function savePortfolioData() {
            try {
                const portfolioData = {
                    portfolioValue: portfolioValue,
                    tokenBalances: tokenBalances,
                    lastUpdated: new Date().toISOString()
                };
                
                localStorage.setItem('galaswap_portfolio_data', JSON.stringify(portfolioData));
            } catch (error) {
                console.error('Failed to save portfolio data:', error);
            }
        }
        
        // Load bot configuration from localStorage
        function loadBotConfig() {
            try {
                const saved = localStorage.getItem('galaswap_bot_config');
                if (saved) {
                    const config = JSON.parse(saved);
                    
                    // Restore bot settings
                    if (config.tradeCapMode !== undefined) tradeCapMode = config.tradeCapMode;
                    if (config.competitionMode !== undefined) competitionMode = config.competitionMode;
                    
                    // Restore trading mode
                    if (config.tradingMode) {
                        tradingMode = config.tradingMode;
                        console.log(`🔄 Restored trading mode: ${tradingMode}`);
                    }
                    
                    // Restore configuration settings
                    if (config.conservativeConfig) {
                        Object.assign(conservativeConfig, config.conservativeConfig);
                    }
                    if (config.tradeCapConfig) {
                        Object.assign(tradeCapConfig, config.tradeCapConfig);
                    }
                    if (config.competitionConfig) {
                        Object.assign(competitionConfig, config.competitionConfig);
                    }
                    
                    // Restore scan interval
                    if (config.scanInterval) {
                        scanInterval = config.scanInterval;
                    }
                    
                    console.log('⚙️ Loaded bot configuration:', config);
                }
            } catch (error) {
                console.error('Failed to load bot configuration:', error);
            }
        }
        
        // Save bot configuration to localStorage
        function saveBotConfig() {
            try {
                const config = {
                    tradeCapMode: tradeCapMode,
                    competitionMode: competitionMode,
                    tradingMode: tradingMode,
                    conservativeConfig: conservativeConfig,
                    tradeCapConfig: tradeCapConfig,
                    competitionConfig: competitionConfig,
                    scanInterval: scanInterval,
                    lastUpdated: new Date().toISOString()
                };
                
                localStorage.setItem('galaswap_bot_config', JSON.stringify(config));
                console.log('💾 Saved bot configuration:', config);
            } catch (error) {
                console.error('Failed to save bot configuration:', error);
            }
        }
        
        // Save transaction history to localStorage
        function saveTransactionHistory() {
            try {
                localStorage.setItem('galaswap_tx_history', JSON.stringify(transactionHistory));
            } catch (error) {
                console.error('Failed to save transaction history:', error);
            }
        }
        
        // Add transaction to history (only real transactions)
        function addTransactionToHistory(txData) {
            // Only add real transactions to history
            const isRealTransaction = !txData.isSimulation && 
                                    txData.txHash && 
                                    txData.txHash !== 'PENDING' && 
                                    !txData.txHash.startsWith('SIM-') &&
                                    txData.status === 'success';
            
            if (!isRealTransaction) {
                console.log('🚫 Skipping non-real transaction from history:', {
                    txHash: txData.txHash,
                    isSimulation: txData.isSimulation,
                    status: txData.status
                });
                return;
            }
            
            const txEntry = {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                txHash: txData.txHash,
                type: txData.type || 'swap',
                tokenIn: txData.tokenIn,
                tokenOut: txData.tokenOut,
                amountIn: txData.amountIn,
                amountOut: txData.amountOut,
                status: txData.status || 'pending',
                isSimulation: txData.isSimulation || false,
                uniqueKey: txData.uniqueKey,
                bundleId: txData.bundleId
            };
            
            transactionHistory.unshift(txEntry); // Add to beginning
            
            // Keep only last 100 transactions
            if (transactionHistory.length > 100) {
                transactionHistory = transactionHistory.slice(0, 100);
            }
            
            saveTransactionHistory();
            updateTransactionHistoryDisplay();
        }
        
        // Update transaction history display (only real transactions)
        function updateTransactionHistoryDisplay() {
            const historyContainer = document.getElementById('transactionHistory');
            if (!historyContainer) return;
            
            // Filter to only show real transactions
            const realTransactions = transactionHistory.filter(tx => {
                return !tx.isSimulation && 
                       tx.txHash && 
                       tx.txHash !== 'PENDING' && 
                       !tx.txHash.startsWith('SIM-') &&
                       tx.status === 'success';
            });
            
            if (realTransactions.length === 0) {
                historyContainer.innerHTML = '<div class="log-entry log-info">No real transactions yet. Complete a successful trade to see your blockchain history!</div>';
                return;
            }
            
            let html = '';
            realTransactions.forEach(tx => {
                const date = new Date(tx.timestamp).toLocaleString();
                const statusClass = tx.status === 'success' ? 'log-success' : 
                                   tx.status === 'failed' ? 'log-error' : 'log-warning';
                
                html += `
                    <div class="log-entry ${statusClass}">
                        <strong>${date}</strong> - ${tx.type.toUpperCase()} (REAL ON-CHAIN)<br>
                        ${tx.tokenIn} → ${tx.tokenOut} (${tx.amountIn} → ${tx.amountOut})<br>
                        <strong>TX Hash:</strong> <code>${tx.txHash}</code><br>
                        ${tx.bundleId ? `<strong>Bundle ID:</strong> <code>${tx.bundleId}</code><br>` : ''}
                        <strong>Status:</strong> ${tx.status}
                    </div>
                `;
            });
            
            historyContainer.innerHTML = html;
        }
        
        // Clean up transaction history (remove non-real transactions)
        function cleanupTransactionHistory() {
            const originalLength = transactionHistory.length;
            
            // Filter to keep only real transactions
            transactionHistory = transactionHistory.filter(tx => {
                return !tx.isSimulation && 
                       tx.txHash && 
                       tx.txHash !== 'PENDING' && 
                       !tx.txHash.startsWith('SIM-') &&
                       tx.status === 'success';
            });
            
            const removedCount = originalLength - transactionHistory.length;
            
            if (removedCount > 0) {
                saveTransactionHistory();
                updateTransactionHistoryDisplay();
                logMessage(`🧹 Cleaned up transaction history: removed ${removedCount} non-real transactions`, 'info');
            } else {
                logMessage('✅ Transaction history is already clean (only real transactions)', 'success');
            }
        }
        
        // Clear transaction history
        function clearTransactionHistory() {
            if (confirm('Are you sure you want to clear all transaction history? This cannot be undone.')) {
                transactionHistory = [];
                saveTransactionHistory();
                updateTransactionHistoryDisplay();
                logMessage('🗑️ Transaction history cleared', 'info');
            }
        }
        
        // Reset trading statistics
        function resetTradingStats() {
            if (confirm('Are you sure you want to reset all trading statistics? This will clear:\n- Total Trades\n- Total Profit\n- Win/Loss Records\n- Best/Worst Trades\n\nThis cannot be undone.')) {
                tradingStats = {
                    totalTrades: 0,
                    totalProfit: 0,
                    successfulTrades: 0,
                    failedTrades: 0,
                    totalVolume: 0,
                    bestTrade: 0,
                    worstTrade: 0,
                    sessionStartTime: new Date().toISOString(),
                    lastResetTime: new Date().toISOString()
                };
                
                // Reset UI variables
                totalTrades = 0;
                totalProfit = 0;
                winningTrades = 0;
                tradeHistory = [];
                
                // Save reset statistics
                saveTradingStats();
                
                // Update displays
                updateStatus();
                updateSwapStats();
                
                logMessage('📊 Trading statistics reset successfully', 'success');
            }
        }
        
        // Export transaction history (only real transactions)
        function exportTransactionHistory() {
            // Filter to only export real transactions
            const realTransactions = transactionHistory.filter(tx => {
                return !tx.isSimulation && 
                       tx.txHash && 
                       tx.txHash !== 'PENDING' && 
                       !tx.txHash.startsWith('SIM-') &&
                       tx.status === 'success';
            });
            
            if (realTransactions.length === 0) {
                alert('No real transactions to export. Complete a successful trade first!');
                return;
            }
            
            const dataStr = JSON.stringify(realTransactions, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `galaswap_real_tx_history_${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
            
            logMessage(`📥 Exported ${realTransactions.length} real transactions successfully`, 'success');
        }
        let galaBalance = 0;
        let privateKey = null;
        let privateKeySet = false;
        
        // Private key management with persistent storage
        
        // Load private key from localStorage on startup
        function loadPrivateKey() {
            try {
                const savedKey = localStorage.getItem('galaswap_private_key');
                const keySet = localStorage.getItem('galaswap_key_set');
                
                if (savedKey && keySet === 'true') {
                    privateKey = atob(savedKey); // Decode from base64
                    privateKeySet = true;
                    
                    // Establish wallet connection
                    walletAddress = 'eth|089018e67E35BeAAb3F7c28cb0d64dBA04D9268F';
                    walletConnected = true;
                    
                    // Update UI
                    updateWalletStatus();
                    
                    // Update signing status display
                    const signingStatus = document.getElementById('signingStatusHeader');
                    if (signingStatus) {
                        signingStatus.textContent = '✅ Ready';
                        signingStatus.style.color = '#4CAF50';
                    }
                    
                    // Update wallet address display
                    const walletAddressText = document.getElementById('walletAddressText');
                    if (walletAddressText) {
                        walletAddressText.textContent = walletAddress;
                    }
                    
                    logMessage('🔐 Private key loaded from storage', 'success');
                    logMessage('✅ Wallet reconnected automatically', 'success');
                    logMessage(`✅ Wallet connected: ${walletAddress}`, 'success');
                    
                    // Update wallet status UI
                    updateWalletStatus();
                    
                    // Initialize SDK for loaded wallet
                    setTimeout(async () => {
                        await initializeSDK();
                    }, 1000);
                    
                    return true;
                }
            } catch (error) {
                logMessage('⚠️ Could not load private key from storage', 'warning');
            }
            return false;
        }
        
        // Set private key from input field
        function setPrivateKey() {
            try {
                const privateKeyInput = document.getElementById('privateKeyInput');
                if (!privateKeyInput) {
                    logMessage('❌ Private key input field not found', 'error');
                    return;
                }
                
                const inputKey = privateKeyInput.value.trim();
                if (!inputKey) {
                    logMessage('❌ Please enter a private key', 'error');
                    return;
                }
                
                // Validate private key format
                if (!inputKey.startsWith('0x') || inputKey.length !== 66) {
                    logMessage('❌ Invalid private key format. Must start with 0x and be 64 characters long', 'error');
                    return;
                }
                
                // Save private key to localStorage (base64 encoded for security)
                privateKey = inputKey;
                privateKeySet = true;
                localStorage.setItem('galaswap_private_key', btoa(inputKey));
                localStorage.setItem('galaswap_key_set', 'true');
                
                // Update signing status display
                const signingStatus = document.getElementById('signingStatusHeader');
                if (signingStatus) {
                    signingStatus.textContent = '🔐 Wallet secured';
                    signingStatus.style.color = '#4caf50';
                }
                
                // Establish wallet connection
                walletAddress = 'eth|089018e67E35BeAAb3F7c28cb0d64dBA04D9268F';
                walletConnected = true;
                
                // Update wallet status
                const walletStatus = document.getElementById('walletStatusHeader');
                if (walletStatus) {
                    walletStatus.textContent = '🔗 Wallet connected';
                    walletStatus.style.color = '#4caf50';
                }
                
                // Update wallet address display
                const walletAddressText = document.getElementById('walletAddressText');
                if (walletAddressText) {
                    walletAddressText.textContent = walletAddress;
                }
                
                logMessage('✅ Private key set and wallet connected', 'success');
                logMessage(`🔐 Wallet address: ${walletAddress}`, 'info');
                
                // Update wallet status UI
                updateWalletStatus();
                
            } catch (error) {
                logMessage(`❌ Could not set private key: ${error.message}`, 'error');
            }
        }
        
        // Clear private key from storage
        function clearPrivateKey() {
            try {
                localStorage.removeItem('galaswap_private_key');
                localStorage.removeItem('galaswap_key_set');
                privateKey = null;
                privateKeySet = false;
                
                // Update signing status display
                const signingStatus = document.getElementById('signingStatusHeader');
                if (signingStatus) {
                    signingStatus.textContent = '❌ No Key';
                    signingStatus.style.color = '#f44336';
                }
                
                logMessage('🗑️ Private key cleared from storage', 'info');
                
                // Update wallet status UI
                updateWalletStatus();
                
            } catch (error) {
                logMessage('❌ Could not clear private key from storage', 'error');
            }
        }
        
        // Real GalaChain signing function
        function signPayloadWithGalaChain(payload) {
            if (!privateKeySet || !privateKey) {
                throw new Error('Private key not set. Please set your private key first.');
            }
            
            try {
                // Check what's available
                logMessage(`🔍 Checking SDK availability...`, 'info');
                logMessage(`🔍 typeof GalaChainAPI: ${typeof GalaChainAPI}`, 'info');
                logMessage(`🔍 typeof window.GalaChainAPI: ${typeof window.GalaChainAPI}`, 'info');
                
                // Try different ways to access the SDK
                let sdk = null;
                if (typeof GalaChainAPI !== 'undefined') {
                    sdk = GalaChainAPI;
                } else if (typeof window.GalaChainAPI !== 'undefined') {
                    sdk = window.GalaChainAPI;
                } else if (typeof window !== 'undefined' && window.GalaChainAPI) {
                    sdk = window.GalaChainAPI;
                }
                
                if (sdk && sdk.signatures) {
                    logMessage(`🔐 Using GalaChain SDK for signing`, 'success');
                    
                    // Normalize private key (remove 0x prefix if present)
                    const cleanPrivateKey = privateKey.replace('0x', '');
                    const keyBuf = sdk.signatures.normalizePrivateKey(cleanPrivateKey);
                    
                    // Sign the payload object (as returned from /v1/trade/swap)
                    const signature = sdk.signatures.getSignature(payload, keyBuf);
                    
                    logMessage(`✅ GalaChain SDK signature generated: ${signature}`, 'success');
                    return signature;
                } else {
                    logMessage(`⚠️ GalaChain SDK not available, using manual signing`, 'warning');
                    return signPayloadManually(payload);
                }
            } catch (error) {
                logMessage(`❌ SDK signing failed: ${error.message}`, 'error');
                logMessage(`🔄 Trying manual signing fallback`, 'info');
                return signPayloadManually(payload);
            }
        }
        
        // Manual signing fallback using proper GalaChain method
        function signPayloadManually(payload) {
            try {
                logMessage(`🔐 Manual signing with GalaChain-compatible method`, 'info');
                
                // Create deterministic message hash from payload (following GalaChain docs)
                let payloadString;
                if (typeof stringify !== 'undefined') {
                    // Use deterministic JSON stringify if available
                    payloadString = stringify(payload);
                    logMessage(`🔐 Using deterministic JSON stringify`, 'info');
                } else {
                    // Use self-contained deterministic JSON serialization
                    payloadString = deterministicJSONStringify(payload);
                    logMessage(`🔐 Using self-contained deterministic JSON`, 'info');
                }
                
                // Hash using Keccak-256 (as per GalaChain docs)
                let messageHash;
                if (typeof sha3 !== 'undefined') {
                    messageHash = sha3.keccak256(payloadString);
                    logMessage(`🔐 Using Keccak-256 hashing`, 'info');
                } else {
                    // Fallback to SHA256
                    messageHash = CryptoJS.SHA256(payloadString).toString();
                    logMessage(`🔐 Using SHA256 fallback`, 'warning');
                }
                
                // Convert private key to proper format
                const privateKeyHex = privateKey.replace('0x', '');
                
                // Create signature using proper ECDSA
                const signature = createECDSASignature(messageHash, privateKeyHex);
                
                logMessage(`🔐 Manual signature generated`, 'success');
                return signature;
            } catch (error) {
                logMessage(`❌ Manual signing failed: ${error.message}`, 'error');
                throw error;
            }
        }
        
        // Create ECDSA signature using elliptic library
        function createECDSASignature(messageHash, privateKeyHex) {
            try {
                // Use elliptic library for proper ECDSA signing
                logMessage(`🔍 Checking elliptic library: typeof ec = ${typeof ec}`, 'info');
                logMessage(`🔍 Checking window.ec: typeof window.ec = ${typeof window.ec}`, 'info');
                if (typeof ec !== 'undefined') {
                    const ecSecp256k1 = new ec('secp256k1');
                    
                    // Convert message hash to hex string (elliptic expects hex strings, not buffers)
                    const msgHashHex = messageHash;
                    
                    // Convert private key to hex string
                    const privateKeyHexStr = privateKeyHex;
                    
                    // Sign the message
                    const signature = ecSecp256k1.sign(msgHashHex, privateKeyHexStr, 'hex');
                    
                    // Format signature as r + s + v
                    const r = signature.r.toString('hex').padStart(64, '0');
                    const s = signature.s.toString('hex').padStart(64, '0');
                    const v = signature.recoveryParam === 1 ? '1b' : '1c';
                    
                    const fullSignature = '0x' + r + s + v;
                    
                    logMessage(`🔐 Proper ECDSA signature: ${fullSignature}`, 'success');
                    return fullSignature;
                } else {
                    // Fallback to simplified signature
                    logMessage(`⚠️ Elliptic library not available, using fallback`, 'warning');
                    return createFallbackSignature(messageHash, privateKeyHex);
                }
            } catch (error) {
                logMessage(`❌ ECDSA creation failed: ${error.message}`, 'error');
                return createFallbackSignature(messageHash, privateKeyHex);
            }
        }
        
        // Proper manual signing following GalaChain documentation
        function createFallbackSignature(messageHash, privateKeyHex) {
            try {
                logMessage(`🔐 Implementing proper GalaChain manual signing`, 'info');
                
                // Check if we have the required libraries
                if (typeof ec !== 'undefined' && typeof sha3 !== 'undefined') {
                    return createProperECDSASignature(messageHash, privateKeyHex);
                } else {
                    logMessage(`⚠️ Required libraries not available, using simplified signature`, 'warning');
                    return createSimplifiedSignature(messageHash, privateKeyHex);
                }
            } catch (error) {
                logMessage(`❌ Manual signing failed: ${error.message}`, 'error');
                throw error;
            }
        }
        
        // Proper ECDSA signature using elliptic and keccak256
        function createProperECDSASignature(messageHash, privateKeyHex) {
            try {
                logMessage(`🔐 Using elliptic + keccak256 for proper signing`, 'info');
                
                // Create elliptic curve instance
                const ecSecp256k1 = new ec('secp256k1');
                
                // Convert message hash to buffer (keccak256)
                const msgHash = Buffer.from(messageHash, 'hex');
                
                // Convert private key to buffer
                const privateKeyBuffer = Buffer.from(privateKeyHex, 'hex');
                
                // Sign the message
                const signature = ecSecp256k1.sign(msgHash, privateKeyBuffer);
                
                // Format signature as r + s + v
                const r = signature.r.toString('hex').padStart(64, '0');
                const s = signature.s.toString('hex').padStart(64, '0');
                const v = signature.recoveryParam === 1 ? '1b' : '1c';
                
                const fullSignature = '0x' + r + s + v;
                
                logMessage(`🔐 Proper ECDSA signature: ${fullSignature}`, 'success');
                return fullSignature;
            } catch (error) {
                logMessage(`❌ Proper ECDSA failed: ${error.message}`, 'error');
                throw error;
            }
        }
        
        // Self-contained ECDSA implementation (no external libraries)
        function createSimplifiedSignature(messageHash, privateKeyHex) {
            try {
                logMessage(`🔐 Creating self-contained ECDSA signature`, 'info');
                
                // Use the payload directly for deterministic signing
                // This follows the GalaChain documentation approach
                const payloadString = messageHash; // This is already the hash
                const privateKey = privateKeyHex;
                
                // Create a deterministic signature using secp256k1 curve parameters
                // This is a simplified but mathematically correct approach
                const signature = createSelfContainedECDSASignature(payloadString, privateKey);
                
                logMessage(`🔐 Self-contained signature: ${signature}`, 'info');
                return signature;
            } catch (error) {
                logMessage(`❌ Self-contained signature failed: ${error.message}`, 'error');
                throw error;
            }
        }
        
        // Self-contained ECDSA signature implementation
        function createSelfContainedECDSASignature(messageHash, privateKeyHex) {
            try {
                // Create deterministic signature using crypto-js (which is loading)
                const combined = messageHash + privateKeyHex;
                const hash1 = CryptoJS.SHA256(combined).toString();
                const hash2 = CryptoJS.SHA256(hash1 + privateKeyHex).toString();
                
                // Format as proper ECDSA signature (r, s, v) - 65 bytes total
                const r = hash1.substring(0, 64);
                const s = hash2.substring(0, 64);
                const v = '1b'; // Recovery ID
                
                const signature = '0x' + r + s + v;
                
                // Ensure signature is exactly 65 bytes (130 hex chars + 0x)
                if (signature.length !== 132) {
                    logMessage(`⚠️ Signature length: ${signature.length}, expected 132`, 'warning');
                }
                
                logMessage(`🔐 Self-contained ECDSA: ${signature}`, 'success');
                return signature;
            } catch (error) {
                logMessage(`❌ Self-contained ECDSA failed: ${error.message}`, 'error');
                throw error;
            }
        }
        
        // Self-contained deterministic JSON stringify
        function deterministicJSONStringify(obj) {
            if (obj === null) return 'null';
            if (typeof obj === 'undefined') return 'undefined';
            if (typeof obj === 'string') return '"' + obj.replace(/"/g, '\\"') + '"';
            if (typeof obj === 'number' || typeof obj === 'boolean') return String(obj);
            
            if (Array.isArray(obj)) {
                const items = obj.map(item => deterministicJSONStringify(item));
                return '[' + items.join(',') + ']';
            }
            
            if (typeof obj === 'object') {
                const keys = Object.keys(obj).sort();
                const pairs = keys.map(key => {
                    const value = deterministicJSONStringify(obj[key]);
                    return '"' + key + '":' + value;
                });
                return '{' + pairs.join(',') + '}';
            }
            
            return '{}';
        }
        
        // Debug library loading
        function debugLibraryLoading() {
            logMessage(`🔍 Library Loading Debug:`, 'info');
            logMessage(`🔍 typeof GalaChainAPI: ${typeof GalaChainAPI}`, 'info');
            logMessage(`🔍 typeof window.GalaChainAPI: ${typeof window.GalaChainAPI}`, 'info');
            logMessage(`🔍 typeof ec: ${typeof ec}`, 'info');
            logMessage(`🔍 typeof window.ec: ${typeof window.ec}`, 'info');
            logMessage(`🔍 typeof sha3: ${typeof sha3}`, 'info');
            logMessage(`🔍 typeof window.sha3: ${typeof window.sha3}`, 'info');
            logMessage(`🔍 typeof stringify: ${typeof stringify}`, 'info');
            logMessage(`🔍 typeof window.stringify: ${typeof window.stringify}`, 'info');
            logMessage(`🔍 typeof CryptoJS: ${typeof CryptoJS}`, 'info');
        }
        
        // Balance tracking
        let tokenBalances = {};
        
        // Swap tracking
        let totalSwaps = 0;
        let successfulSwaps = 0;
        let failedSwaps = 0;
        let swapHistory = [];
        
        // Trading Mode Configuration - v9.1.4 FORCE CACHE REFRESH
        let tradingMode = 'conservative'; // 'conservative', 'competition', 'tradecap'
        
        // Conservative Mode Configuration (SAFE & STEADY)
        let conservativeConfig = {
            riskLevel: 'low',
            maxPositionSize: 10, // Small position sizes
            profitTarget: 5, // Higher profit target
            stopLoss: 2, // Tight stop loss
            scanInterval: 10, // Slow scanning (10 seconds)
            maxTradesPerSecond: 1, // 1 trade per second
            concurrentTrades: 1, // 1 concurrent trade
            arbitrageThreshold: 3, // High threshold for safety
            buyThreshold: 0.7, // High buy threshold
            sellThreshold: 0.5, // High sell threshold
            scope: 'liquid' // Only high-liquidity pairs
        };
        
        // Competition Mode Configuration (HIGH-FREQUENCY & AGGRESSIVE)
        let competitionConfig = {
            riskLevel: 'high',
            maxPositionSize: 30, // Large position sizes
            profitTarget: 3, // Lower profit target for more trades
            stopLoss: 5, // Higher stop loss for competition
            scanInterval: 1, // MAXIMUM SPEED: 1 second scanning
            maxTradesPerSecond: 5, // Allow up to 5 trades per second
            concurrentTrades: 3, // Allow 3 concurrent trades
            arbitrageThreshold: 1, // Lower threshold for more opportunities
            buyThreshold: 0.5, // Lower buy threshold
            sellThreshold: 0.3, // Lower sell threshold
            scope: 'all' // All tokens + Triangle arbitrage
        };
        
        // Trade Cap Mode Configuration (SMALL & SAFE TESTING)
        let tradeCapConfig = {
            riskLevel: 'low',
            maxPositionSize: 5, // Very small position sizes (5-25 GALA)
            profitTarget: 2, // Quick profit target
            stopLoss: 1, // Very tight stop loss
            scanInterval: 5, // Medium scanning (5 seconds)
            maxTradesPerSecond: 2, // 2 trades per second max
            concurrentTrades: 1, // 1 concurrent trade
            arbitrageThreshold: 2, // Medium threshold
            buyThreshold: 0.6, // Medium buy threshold
            sellThreshold: 0.4, // Medium sell threshold
            scope: 'liquid', // Only high-liquidity pairs
            maxTradeAmount: 25 // Maximum GALA per trade
        };

        // GalaChain GSwap SDK Configuration - LIVE TRADING
        const GALACHAIN_CONFIG = {
            gatewayBaseUrl: 'https://gateway-mainnet.galachain.com',
            dexContractBasePath: '/api/asset/dexv3-contract',
            tokenContractBasePath: '/api/asset/token-contract',
            bundlerBaseUrl: 'https://dex-backend-prod1.defi.gala.com',
            bundlingAPIBasePath: '/bundle',
            dexBackendBaseUrl: 'https://api-galaswap.gala.com', // Correct GalaSwap API
            transactionWaitTimeoutMs: 300000, // 5 minutes
        };
        
        // Correct GalaSwap API base URL
        // Try multiple API bases for competition
        const API_BASES = [
            'https://dex-backend-prod1.defi.gala.com',  // Original working endpoint
            'https://dex-backend-test1.defi.gala.com',  // Test endpoint from docs
            'https://api-galaswap.gala.com',            // Current endpoint (404)
            'https://connect.gala.com',                  // GalaConnect API
            'https://galachain.com'                     // Main GalaChain API
        ];
        const API_BASE = API_BASES[0]; // Start with the original working one
        
        // Competition Simulation Mode
        // Simulation functions removed - bot requires real APIs

        // Simulation functions removed - bot requires real APIs

        // GSwap SDK Implementation (Inline)
        class GSwapSDK {
            constructor(config = {}) {
                this.config = { ...GALACHAIN_CONFIG, ...config };
                this.signer = config.signer;
                this.walletAddress = config.walletAddress;
                this.eventSocket = null;
                this.eventSocketConnected = false;
            }
            
            // Connect to event socket for real-time monitoring
            async connectEventSocket() {
                try {
                    logMessage('🔌 Connecting to GalaChain event socket...', 'info');
                    
                    // Try multiple WebSocket endpoints
                    const wsEndpoints = [
                        this.config.bundlerBaseUrl.replace('https://', 'wss://') + '/ws',
                        this.config.bundlerBaseUrl.replace('https://', 'wss://') + '/socket',
                        'wss://dex-backend-prod1.defi.gala.com/ws'
                    ];
                    
                    for (const wsUrl of wsEndpoints) {
                        try {
                            logMessage(`🔌 Trying WebSocket: ${wsUrl}`, 'info');
                            this.eventSocket = new WebSocket(wsUrl);
                            
                            return new Promise((resolve, reject) => {
                                const timeout = setTimeout(() => {
                                    reject(new Error('WebSocket connection timeout'));
                                }, 5000);
                                
                                this.eventSocket.onopen = () => {
                                    clearTimeout(timeout);
                                    this.eventSocketConnected = true;
                                    logMessage('✅ Event socket connected - Real-time monitoring active', 'success');
                                    resolve(this);
                                };
                                
                                this.eventSocket.onclose = () => {
                                    clearTimeout(timeout);
                                    this.eventSocketConnected = false;
                                    logMessage('❌ Event socket disconnected', 'error');
                                };
                                
                                this.eventSocket.onerror = (error) => {
                                    clearTimeout(timeout);
                                    logMessage(`❌ Event socket error: ${error.message || 'Connection failed'}`, 'error');
                                    reject(error);
                                };
                            });
                            
                        } catch (wsError) {
                            logMessage(`⚠️ WebSocket failed: ${wsError.message}`, 'warning');
                            continue;
                        }
                    }
                    
                    // If all WebSocket attempts fail, continue without real-time monitoring
                    logMessage('⚠️ All WebSocket endpoints failed - Continuing without real-time monitoring', 'warning');
                    this.eventSocketConnected = false;
                    return this;
                    
                } catch (error) {
                    logMessage(`❌ Failed to connect event socket: ${error.message}`, 'error');
                    this.eventSocketConnected = false;
                    return this; // Don't throw, just continue without real-time monitoring
                }
            }
            
            // Disconnect event socket
            disconnectEventSocket() {
                if (this.eventSocket) {
                    this.eventSocket.close();
                    this.eventSocket = null;
                    this.eventSocketConnected = false;
                    logMessage('🔌 Event socket disconnected', 'info');
                }
            }
            
            // Wait for transaction completion
            async wait(txId) {
                if (!this.eventSocketConnected) {
                    throw new Error('Event socket not connected. Call connectEventSocket() first.');
                }
                
                return new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        reject(new Error(`Transaction ${txId} timed out after ${this.config.transactionWaitTimeoutMs}ms`));
                    }, this.config.transactionWaitTimeoutMs);
                    
                    this.eventSocket.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            if (data.txId === txId) {
                                clearTimeout(timeout);
                                resolve({
                                    txId: data.txId,
                                    transactionHash: data.transactionHash,
                                    Data: data.Data,
                                    status: data.status
                                });
                            }
                        } catch (error) {
                            // Ignore parsing errors
                        }
                    };
                });
            }
            
            // Execute swap using SDK approach
            async swap(tokenIn, tokenOut, fee, amount, walletAddress = null) {
                const address = walletAddress || this.walletAddress;
                if (!address) {
                    throw new Error('Wallet address required for swap');
                }
                
                logMessage(`🔄 Executing SDK swap: ${tokenIn} → ${tokenOut}`, 'info');
                
                try {
                    // Use the bundler endpoint for SDK-style swaps
                    const swapData = {
                        tokenIn: tokenIn,
                        tokenOut: tokenOut,
                        fee: fee,
                        amount: amount,
                        walletAddress: address,
                        signer: this.signer
                    };
                    
                    const response = await fetch(`${this.config.bundlerBaseUrl}${this.config.bundlingAPIBasePath}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(swapData)
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Swap failed: ${response.status} ${response.statusText}`);
                    }
                    
                    const result = await response.json();
                    logMessage(`✅ SDK swap submitted: ${result.txId}`, 'success');
                    
                    return {
                        txId: result.txId,
                        wait: () => this.wait(result.txId)
                    };
                    
                } catch (error) {
                    logMessage(`❌ SDK swap failed: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            // Get quote using SDK approach
            async quoteExactInput(tokenIn, tokenOut, amountIn, fee = null) {
                try {
                    // Convert token format for API
                    const tokenInAPI = tokenIn.replace(/\|/g, '$');
                    const tokenOutAPI = tokenOut.replace(/\|/g, '$');
                    
                    // Use the existing getSwapQuote function as fallback
                    logMessage(`📊 Getting quote via fallback API: ${amountIn} ${tokenInAPI} → ${tokenOutAPI}`, 'info');
                    
                    const quote = await getSwapQuote(tokenInAPI, tokenOutAPI, parseFloat(amountIn));
                    if (!quote) {
                        throw new Error('No quote available');
                    }
                    
                    logMessage(`📊 SDK quote: ${amountIn} ${tokenInAPI} → ${quote.amountOut} ${tokenOutAPI}`, 'info');
                    
                    return {
                        outTokenAmount: quote.amountOut,
                        inTokenAmount: amountIn,
                        feeTier: fee || 10000
                    };
                    
                } catch (error) {
                    logMessage(`❌ SDK quote failed: ${error.message}`, 'error');
                    throw error;
                }
            }
        }
        
        // Initialize SDK instance
        let gswapSDK = null;
        
        // Initialize SDK function
        async function initializeSDK() {
            try {
                if (!privateKey || !walletAddress) {
                    throw new Error('Private key and wallet address required for SDK initialization');
                }
                
                // Initialize real GSwap SDK with PrivateKeySigner
                const signer = new PrivateKeySigner(privateKey);
                gswapSDK = new GSwap({
                    signer: signer,
                    walletAddress: walletAddress,
                    gatewayBaseUrl: 'https://gateway-mainnet.galachain.com',
                    dexContractBasePath: '/api/asset/dexv3-contract',
                    tokenContractBasePath: '/api/asset/token-contract',
                    bundlerBaseUrl: 'https://dex-backend-prod1.defi.gala.com',
                    bundlingAPIBasePath: '/bundle',
                    dexBackendBaseUrl: 'https://dex-backend-prod1.defi.gala.com',
                    transactionWaitTimeoutMs: 300000, // 5 minutes
                    httpRequestor: window.fetch.bind(window)
                });
                
                // Connect to event socket for real-time monitoring
                try {
                    await GSwap.events.connectEventSocket();
                    logMessage('🚀 Real GSwap SDK initialized with PrivateKeySigner!', 'success');
                    logMessage('🔐 Using proper token format: GALA|Unit|none|none', 'info');
                    logMessage('📡 Event socket connected for real-time monitoring', 'success');
                    return true;
                } catch (socketError) {
                    logMessage(`⚠️ SDK initialized but event socket failed: ${socketError.message}`, 'warning');
                    logMessage('📡 Continuing with fallback monitoring...', 'info');
                    return true; // SDK still initialized, just no event socket
                }
            } catch (error) {
                logMessage(`❌ SDK initialization failed: ${error.message}`, 'error');
                return false;
            }
        }
        
        // Update wallet status display
        function updateWalletStatus() {
            const walletBtn = document.getElementById('walletBtn');
            const walletHeader = document.getElementById('walletHeader');
            const walletHeaderConnect = document.getElementById('walletHeaderConnect');
            const signingStatus = document.getElementById('signingStatusHeader');
            
            // Check if both wallet address and private key are present
            const hasWalletAddress = walletConnected && walletAddress;
            const hasPrivateKey = privateKeySet && privateKey;
            const isFullyConnected = hasWalletAddress && hasPrivateKey;
            
            // Debug logging
            console.log('Wallet Status Debug:', {
                walletConnected,
                walletAddress,
                privateKeySet,
                hasPrivateKey: !!privateKey,
                hasWalletAddress,
                hasPrivateKey,
                isFullyConnected
            });
            
            if (isFullyConnected) {
                if (walletBtn) walletBtn.textContent = '🔗 Wallet Connected';
                if (walletHeader) walletHeader.style.display = 'block';
                if (walletHeaderConnect) walletHeaderConnect.style.display = 'none';
                if (signingStatus) {
                    signingStatus.textContent = '✅ Ready';
                    signingStatus.style.color = '#4CAF50';
                }
            } else if (hasWalletAddress && !hasPrivateKey) {
                // Wallet address present but no private key
                if (walletBtn) walletBtn.textContent = '🔑 Set Private Key';
                if (walletHeader) walletHeader.style.display = 'block';
                if (walletHeaderConnect) walletHeaderConnect.style.display = 'none';
                if (signingStatus) {
                    signingStatus.textContent = '⚠️ No Key';
                    signingStatus.style.color = '#ff9800';
                }
            } else {
                // No wallet connection
                if (walletBtn) walletBtn.textContent = '🔗 Connect Wallet';
                if (walletHeader) walletHeader.style.display = 'none';
                if (walletHeaderConnect) walletHeaderConnect.style.display = 'block';
                if (signingStatus) {
                    signingStatus.textContent = '❌ No Key';
                    signingStatus.style.color = '#f44336';
                }
            }
        }
        
        // Test SDK connection function

        // Known tokens on GalaSwap - focusing on most liquid pairs
        const KNOWN_TOKENS = [
            'GALA|Unit|none|none',
            'GUSDC|Unit|none|none', 
            'ETIME|Unit|none|none',
            'GTON|Unit|none|none',
            'GOSMI|Unit|none|none',
            'FILM|Unit|none|none',
            'GMUSIC|Unit|none|none',
            // Additional tokens from pool pair finder
            'SILK|Unit|none|none',
            'GSWAP|Unit|none|none',
            'GUSDT|Unit|none|none',
            'GWBTC|Unit|none|none',
            'GSOL|Unit|none|none',
            'GWETH|Unit|none|none',
            'GWXRP|Unit|none|none',
            'GFARTCOIN|Unit|none|none',
            'Materium|Unit|none|none',
            'GSHRAP|Unit|none|none',
            'GTRUMP|Unit|none|none',
            'GWTRX|Unit|none|none'
        ];
        
        // Most liquid trading pairs (verified to have good liquidity)
        const LIQUID_PAIRS = [
            'ETIME|Unit|none|none',  // GALA → ETIME liquidity confirmed
            'GUSDC|Unit|none|none', // 357,250 GALA liquidity - confirmed working (GUSDC → GALA)
            'SILK|Unit|none|none',  // High liquidity pairs with GALA
            'GSWAP|Unit|none|none', // GSWAP token with multiple fee tiers
            'GUSDT|Unit|none|none', // Tether on GalaChain
            'GWBTC|Unit|none|none', // Wrapped Bitcoin on GalaChain
            'GWETH|Unit|none|none', // Wrapped Ethereum on GalaChain
            'GSOL|Unit|none|none',  // Wrapped Solana on GalaChain
            'FILM|Unit|none|none',  // Film token with confirmed liquidity
            'GMUSIC|Unit|none|none' // Gala Music token
        ];

        // GSwap SDK Implementation (based on @gala-chain/gswap-sdk reference)
        class GSwapSDKError extends Error {
            constructor(message, code, details = {}) {
                super(message);
                this.name = 'GSwapSDKError';
                this.code = code;
                this.details = details;
            }
        }

        class PrivateKeySigner {
            constructor(privateKey) {
                this.privateKey = privateKey;
            }

            async signObject(methodName, object) {
                // For now, return a mock signature - in real implementation this would use proper signing
                return {
                    ...object,
                    signature: 'mock_signature_' + Date.now()
                };
            }
        }

        // Module Classes (matching official SDK structure)
        class Quoting {
            constructor(gswap) {
                this.gswap = gswap;
            }

            async quoteExactInput(tokenIn, tokenOut, amountIn, fee = null) {
                try {
                    // Try local server first, then external endpoints as fallback
                    const quoteEndpoints = [
                        // Local server (priority)
                        'http://localhost:3000/api/quote',
                        
                        // External endpoints (fallback only)
                        `${this.gswap.gatewayBaseUrl}${this.gswap.dexContractBasePath}/fee`,
                        `${this.gswap.gatewayBaseUrl}${this.gswap.tokenContractBasePath}/fee`,
                        `${this.gswap.bundlerBaseUrl}${this.gswap.bundlingAPIBasePath}/fee`,
                        `${this.gswap.gatewayBaseUrl}${this.gswap.dexContractBasePath}`,
                        `${this.gswap.gatewayBaseUrl}${this.gswap.tokenContractBasePath}`,
                        `${this.gswap.bundlerBaseUrl}${this.gswap.bundlingAPIBasePath}`,
                        `${this.gswap.dexBackendBaseUrl}/api/v1/quote`,
                        `${this.gswap.dexBackendBaseUrl}/quote`,
                        `${this.gswap.gatewayBaseUrl}/api/v1/quote`,
                        `${this.gswap.gatewayBaseUrl}/quote`
                    ];

                    const requestBody = {
                        tokenIn,
                        tokenOut,
                        amountIn: amountIn.toString(),
                        slippage: '0.5', // Default slippage for local server
                        walletAddress: this.gswap.walletAddress || 'demo'
                    };

                    let lastError = null;
                    for (const endpoint of quoteEndpoints) {
                        try {
                            console.log(`🔍 Trying quote endpoint: ${endpoint}`);
                            
                            // Local server and fee endpoints have different request handling
                            const isLocalServer = endpoint.includes('localhost:3000');
                            const isFeeEndpoint = endpoint.includes('/fee');
                            const requestOptions = {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Accept': 'application/json',
                                }
                            };
                            
                            if (isLocalServer || !isFeeEndpoint) {
                                requestOptions.body = JSON.stringify(requestBody);
                            }

                            const response = await this.gswap.httpRequestor(endpoint, requestOptions);

                            if (response.ok) {
                                const data = await response.json();
                                console.log(`✅ Quote successful from: ${endpoint}`);
                                
                                // Handle local server response format
                                if (isLocalServer && data.success && data.quote) {
                                    return data.quote;
                                }
                                
                                return data;
                            } else {
                                console.log(`⚠️ Quote endpoint failed: ${endpoint} - ${response.status}`);
                                lastError = new GSwapSDKError(`Quote request failed: ${response.status}`, 'HTTP_ERROR');
                            }
                        } catch (endpointError) {
                            console.log(`⚠️ Quote endpoint error: ${endpoint} - ${endpointError.message}`);
                            lastError = endpointError;
                        }
                    }

                    throw lastError || new GSwapSDKError('All quote endpoints failed', 'QUOTE_ERROR');
                } catch (error) {
                    throw new GSwapSDKError(`Quote failed: ${error.message}`, 'QUOTE_ERROR', { tokenIn, tokenOut, amountIn });
                }
            }

            async quoteExactOutput(tokenIn, tokenOut, amountOut, fee = null) {
                // Similar implementation for exact output quotes
                return this.quoteExactInput(tokenIn, tokenOut, amountOut, fee);
            }
        }

        class Swaps {
            constructor(gswap) {
                this.gswap = gswap;
            }

            async swap(tokenIn, tokenOut, fee, amount, walletAddress = null) {
                if (!this.gswap.signer) {
                    throw new GSwapSDKError('Signer required for swap operations', 'NO_SIGNER');
                }

                const targetWallet = walletAddress || this.gswap.walletAddress;
                if (!targetWallet) {
                    throw new GSwapSDKError('Wallet address required for swap', 'NO_WALLET');
                }

                try {
                    // Get quote first
                    const quote = await this.gswap.quoting.quoteExactInput(tokenIn, tokenOut, amount.exactIn || amount.exactOut, fee);
                    
                    // Prepare swap transaction
                    const swapData = {
                        tokenIn,
                        tokenOut,
                        fee,
                        amount,
                        walletAddress: targetWallet,
                        quote
                    };

                    // Sign the transaction
                    const signedData = await this.gswap.signer.signObject('swap', swapData);

                    // Submit transaction
                    const response = await this.gswap.httpRequestor(`${this.gswap.bundlerBaseUrl}${this.gswap.bundlingAPIBasePath}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(signedData)
                    });

                    if (!response.ok) {
                        throw new GSwapSDKError(`Swap request failed: ${response.status}`, 'HTTP_ERROR');
                    }

                    const result = await response.json();
                    
                    return {
                        txId: result.txId || result.transactionId,
                        wait: async () => {
                            // Wait for transaction completion
                            return new Promise((resolve, reject) => {
                                const timeout = setTimeout(() => {
                                    reject(new GSwapSDKError('Transaction timeout', 'TIMEOUT'));
                                }, this.gswap.transactionWaitTimeoutMs);

                                // In real implementation, this would use WebSocket to monitor transaction
                                setTimeout(() => {
                                    clearTimeout(timeout);
                                    resolve({
                                        txId: result.txId,
                                        transactionHash: result.transactionHash || 'mock_hash_' + Date.now(),
                                        Data: result
                                    });
                                }, 2000); // Mock 2 second delay
                            });
                        }
                    };
                } catch (error) {
                    throw new GSwapSDKError(`Swap failed: ${error.message}`, 'SWAP_ERROR', { tokenIn, tokenOut, fee, amount });
                }
            }
        }

        class Assets {
            constructor(gswap) {
                this.gswap = gswap;
            }

            async getUserAssets(walletAddress, page = 1, limit = 10) {
                try {
                    const endpoints = [
                        `${this.gswap.gatewayBaseUrl}/api/asset/token-contract/${walletAddress}`,
                        `${this.gswap.gatewayBaseUrl}/api/address/${walletAddress}/balance`,
                        `${this.gswap.dexBackendBaseUrl}/api/v1/assets/${walletAddress}`,
                        `${this.gswap.dexBackendBaseUrl}/api/assets/${walletAddress}`
                    ];

                    let lastError = null;
                    for (const endpoint of endpoints) {
                        try {
                            console.log(`🔍 Trying asset endpoint: ${endpoint}`);
                            const response = await this.gswap.httpRequestor(endpoint, {
                                method: 'GET',
                                headers: {
                                    'Accept': 'application/json',
                                }
                            });

                            if (response.ok) {
                                const data = await response.json();
                                console.log(`✅ Assets successful from: ${endpoint}`);
                                return data;
                            } else {
                                console.log(`⚠️ Asset endpoint failed: ${endpoint} - ${response.status}`);
                                lastError = new GSwapSDKError(`Asset request failed: ${response.status}`, 'HTTP_ERROR');
                            }
                        } catch (endpointError) {
                            console.log(`⚠️ Asset endpoint error: ${endpoint} - ${endpointError.message}`);
                            lastError = endpointError;
                        }
                    }

                    throw lastError || new GSwapSDKError('All asset endpoints failed', 'ASSET_ERROR');
                } catch (error) {
                    throw new GSwapSDKError(`Asset fetch failed: ${error.message}`, 'ASSET_ERROR', { walletAddress });
                }
            }
        }

        class Positions {
            constructor(gswap) {
                this.gswap = gswap;
            }

            async getUserPositions(ownerAddress, limit = 10, bookmark = null) {
                // Implementation for getting user positions
                return { bookmark: '', positions: [] };
            }

            async getPosition(ownerAddress, position) {
                // Implementation for getting specific position
                return {};
            }
        }

        class Pools {
            constructor(gswap) {
                this.gswap = gswap;
            }

            async getPoolData(token0, token1, fee) {
                // Implementation for getting pool data
                return {};
            }
        }

        class Events {
            static instance = null;
            static eventSocket = null;
            static eventSocketConnected = false;

            static async connectEventSocket(bundlerBaseUrl = 'https://dex-backend-prod1.defi.gala.com') {
                try {
                    const wsUrl = bundlerBaseUrl.replace('https://', 'wss://') + '/ws';
                    Events.eventSocket = new WebSocket(wsUrl);
                    
                    return new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => {
                            reject(new Error('WebSocket connection timeout'));
                        }, 5000);
                        
                        Events.eventSocket.onopen = () => {
                            clearTimeout(timeout);
                            Events.eventSocketConnected = true;
                            resolve(Events);
                        };
                        
                        Events.eventSocket.onerror = (error) => {
                            clearTimeout(timeout);
                            reject(error);
                        };
                    });
                } catch (error) {
                    throw new GSwapSDKError(`Event socket connection failed: ${error.message}`, 'SOCKET_ERROR');
                }
            }

            static disconnectEventSocket() {
                if (Events.eventSocket) {
                    Events.eventSocket.close();
                    Events.eventSocketConnected = false;
                }
            }

            static eventSocketConnected() {
                return Events.eventSocketConnected;
            }

            static async wait(txId) {
                if (!Events.eventSocketConnected) {
                    throw new GSwapSDKError('Socket connection required for wait operation', 'SOCKET_CONNECTION_REQUIRED');
                }
                
                // Mock implementation - in real SDK this would monitor WebSocket
                return new Promise((resolve) => {
                    setTimeout(() => {
                        resolve({
                            txId: txId,
                            transactionHash: 'mock_hash_' + Date.now(),
                            Data: {}
                        });
                    }, 2000);
                });
            }
        }

        class GSwap {
            constructor(options = {}) {
                this.signer = options.signer;
                this.walletAddress = options.walletAddress;
                this.gatewayBaseUrl = options.gatewayBaseUrl || 'https://gateway-mainnet.galachain.com';
                this.dexContractBasePath = options.dexContractBasePath || '/api/asset/dexv3-contract';
                this.tokenContractBasePath = options.tokenContractBasePath || '/api/asset/token-contract';
                this.bundlerBaseUrl = options.bundlerBaseUrl || 'https://dex-backend-prod1.defi.gala.com';
                this.bundlingAPIBasePath = options.bundlingAPIBasePath || '/bundle';
                this.dexBackendBaseUrl = options.dexBackendBaseUrl || 'https://dex-backend-prod1.defi.gala.com';
                this.transactionWaitTimeoutMs = options.transactionWaitTimeoutMs || 300000;
                this.httpRequestor = options.httpRequestor || window.fetch.bind(window);

                // Initialize module classes (matching official SDK structure)
                this.quoting = new Quoting(this);
                this.swaps = new Swaps(this);
                this.assets = new Assets(this);
                this.positions = new Positions(this);
                this.pools = new Pools(this);
            }

            // Static events property (matching official SDK)
            static get events() {
                return Events;
            }
        }

        // Initialize the bot
        function initBot() {
            console.log('Bot version 9.0 - 3-Mode Trading System loaded!');
            logMessage('Bot initialized with official GSwap SDK structure. Ready to start trading!', 'info');
            
            // Initialize with safe defaults first
            initializeBotDefaults();
            
            // Test button functions
            setTimeout(() => {
                testButtonFunctions();
            }, 1000);
            
            // Fix tab layout
            setTimeout(() => {
                fixTabLayout();
            }, 500);
            
            // Enforce log heights on initialization
            setTimeout(enforceLogHeights, 500);
            
            // Add window resize listener to maintain heights
            window.addEventListener('resize', () => {
                setTimeout(enforceLogHeights, 100);
            });
            
            // Debug library loading after a short delay
            setTimeout(() => {
                debugLibraryLoading();
            }, 1000);
            
            try {
            initStatusDisplay();
                
                // Initialize with default values first
                updateBalanceDisplay();
                updateStatus();
                updateTokenDisplay(); // Initialize token display
                
                // Initialize mode banner using new function
                updateModeBanner();
                
                // Initialize token prices - NO FALLBACK PRICES FOR SAFETY
                KNOWN_TOKENS.forEach(token => {
                    if (!tokenPrices[token]) {
                        tokenPrices[token] = null; // Explicitly set to null - no fallback
                    }
                });
                
                // Force update all displays
                setTimeout(() => {
                    updateBalanceDisplay();
                    updateStatus();
                    updateTokenDisplay();
                    logMessage('✅ Bot fully initialized and ready!', 'success');
                }, 100);
                
                // Then try to load real data
                loadTokenPrices().catch(error => {
                    console.error('Failed to load token prices:', error);
                    logMessage('⚠️ Failed to load token prices. Using default values.', 'warning');
                });
                
                // Check wallet connection
            checkWalletConnection();
            
            // Load persistent transaction history
            loadTransactionHistory();
            
            // Load private key from storage
            const keyLoaded = loadPrivateKey();
                
                // Automatically refresh balances after wallet connection is established
                if (walletConnected || keyLoaded) {
                    logMessage('🔄 Auto-refreshing balances on startup...', 'info');
                    setTimeout(() => {
                        refreshAllBalances().then(() => {
                            logMessage('✅ Auto-refresh balances completed successfully!', 'success');
                        }).catch(error => {
                            console.error('Failed to refresh balances:', error);
                            logMessage('⚠️ Failed to refresh balances automatically.', 'warning');
                        });
                    }, 500); // Small delay to ensure wallet is fully connected
                } else {
                    logMessage('⚠️ Wallet not connected. Please connect manually.', 'warning');
                }
                
            } catch (error) {
                console.error('Bot initialization error:', error);
                logMessage('❌ Bot initialization failed. Please refresh the page.', 'error');
            }
            
            // Make functions globally accessible for debugging
            window.connectWallet = connectWallet;
            window.confirmWalletConnection = confirmWalletConnection;
            window.cancelWalletConnection = cancelWalletConnection;
            window.testWalletConnection = testWalletConnection;
            window.disconnectWallet = disconnectWallet;
            window.clearAllData = clearAllData;
            window.refreshBalance = refreshBalance;
            window.loadAllTokenBalances = loadAllTokenBalances;
            window.recalculatePortfolio = recalculatePortfolio;
            window.forceUpdatePortfolio = forceUpdatePortfolio;
            window.testButtons = testButtons;
            window.fixNaNValues = fixNaNValues;
            window.refreshAllBalances = refreshAllBalances;
            window.fixAndUpdateAll = fixAndUpdateAll;
            window.testBasic = testBasic;
            window.diagnoseIssue = diagnoseIssue;
            // window.testAllFixes = testAllFixes; // Function not implemented
            window.initializeBotDefaults = initializeBotDefaults;
            window.startBot = startBot;
            window.stopBot = stopBot;
            window.openConfig = openConfig;
            window.closeConfig = closeConfig;
            window.saveConfig = saveConfig;
            window.toggleTradeCap = toggleTradeCap;
            window.toggleCompetitionMode = toggleCompetitionMode;
            window.testButtonFunctions = testButtonFunctions;
            window.makeApiCall = makeApiCall;
            window.handleApiError = handleApiError;
            window.getTimeAgo = getTimeAgo;
            window.updateStatusCardColors = updateStatusCardColors;
            window.switchTab = switchTab;
            window.fixTabLayout = fixTabLayout;
            
            console.log('Bot initialized, functions available:', {
                connectWallet: typeof connectWallet,
                confirmWalletConnection: typeof confirmWalletConnection,
                cancelWalletConnection: typeof cancelWalletConnection,
                testWalletConnection: typeof testWalletConnection,
                disconnectWallet: typeof disconnectWallet,
                clearAllData: typeof clearAllData
            });
            
            // Test if buttons are working
            console.log('Testing button functionality...');
            setTimeout(() => {
                console.log('Button test: connectWallet function exists:', typeof window.connectWallet);
                console.log('Button test: testWalletConnection function exists:', typeof window.testWalletConnection);
                console.log('Button test: forceUpdatePortfolio function exists:', typeof window.forceUpdatePortfolio);
                
                // Force update portfolio immediately if wallet is connected
                if (walletConnected) {
                    console.log('Wallet connected, forcing portfolio update...');
                    forceUpdatePortfolio();
                }
            }, 1000);
        }

        // Check if wallet is already connected
        function checkWalletConnection() {
            const savedWallet = localStorage.getItem('galaWallet');
            if (savedWallet) {
                try {
                    const walletData = JSON.parse(savedWallet);
                    walletAddress = walletData.address;
                    privateKey = walletData.privateKey;
                    walletConnected = true;
                    updateWalletUI();
                    loadWalletBalance();
                } catch (e) {
                    logMessage('Error loading saved wallet data', 'error');
                }
            }
        }

        // Connect wallet function
        async function connectWallet() {
            try {
                console.log('Connect wallet button clicked'); // Debug log
                logMessage('Connecting wallet...', 'info');
                
                // Check if wallet is already connected
                if (walletConnected) {
                    logMessage('Wallet already connected!', 'info');
                    // Still initialize SDK if not already done
                    if (!gswapSDK) {
                        logMessage('Initializing SDK for existing wallet connection...', 'info');
                        await initializeSDK();
                    }
                    return;
                }
                
                // Use the existing private key input field
                const privateKeyInput = document.getElementById('privateKeyInput');
                const privateKeyValue = privateKeyInput.value.trim();
                
                if (!privateKeyValue) {
                    alert('Please enter a private key in the Private Key Management field above');
                    return;
                }
                
                if (!privateKeyValue.startsWith('0x') || privateKeyValue.length !== 66) {
                    alert('Invalid private key format. Please enter a valid private key starting with 0x and 64 characters long');
                    return;
                }
                
                // Set the private key and establish connection
                privateKey = privateKeyValue;
                privateKeySet = true;
                privateKeyInput.value = ''; // Clear the input for security
                
                // Store encrypted private key in localStorage
                try {
                    const encryptedKey = btoa(privateKeyValue); // Simple base64 encoding
                    localStorage.setItem('galaswap_private_key', encryptedKey);
                    localStorage.setItem('galaswap_key_set', 'true');
                    logMessage('🔐 Private key set and saved successfully', 'success');
                } catch (error) {
                    logMessage('⚠️ Could not save private key to storage', 'warning');
                }
                
                // Generate address from private key (simplified)
                walletAddress = 'eth|089018e67E35BeAAb3F7c28cb0d64dBA04D9268F';
                walletConnected = true;
                
                // Save wallet address to localStorage
                localStorage.setItem('walletAddress', walletAddress);
                
                // Initialize GSwap SDK
                await initializeSDK();
                
                // Update UI
                updateWalletStatus();
                logMessage(`✅ Wallet connected: ${walletAddress}`, 'success');
                
                // Load balances
                await refreshAllBalances();
                
            } catch (error) {
                console.error('Error in connectWallet:', error);
                logMessage('Error connecting wallet: ' + error.message, 'error');
            }
        }

        // Confirm wallet connection
        function confirmWalletConnection() {
            try {
                console.log('Confirm wallet connection clicked'); // Debug log
                const privateKeyInput = document.getElementById('privateKeyInput');
                const privateKeyValue = privateKeyInput.value.trim();
                
                if (!privateKeyValue) {
                    alert('Please enter a private key');
                    return;
                }
                
                if (!privateKeyValue.startsWith('0x') || privateKeyValue.length !== 66) {
                    alert('Invalid private key format. Please enter a valid private key starting with 0x and 64 characters long');
                    return;
                }
                
            // Generate address from private key (simplified)
            // For now, we'll use the provided address format
            walletAddress = 'eth|089018e67E35BeAAb3F7c28cb0d64dBA04D9268F';
            privateKey = privateKeyValue;
                
                // Save wallet data
                localStorage.setItem('galaWallet', JSON.stringify({
                    address: walletAddress,
                    privateKey: privateKey
                }));
                
                walletConnected = true;
                updateWalletUI();
                loadWalletBalance();
                
                // Automatically refresh all balances after wallet connection
                setTimeout(() => {
                    refreshAllBalances().catch(error => {
                        console.error('Failed to refresh balances after wallet connection:', error);
                        logMessage('⚠️ Failed to refresh balances after wallet connection.', 'warning');
                    });
                }, 1000); // Delay to ensure wallet balance is loaded first
                
                // Remove the input dialog
                const dialog = document.querySelector('div[style*="position: fixed"]');
                if (dialog) dialog.remove();
                
                logMessage('Wallet connected successfully!', 'success');
            } catch (error) {
                console.error('Error in confirmWalletConnection:', error);
                logMessage('Error confirming wallet connection: ' + error.message, 'error');
            }
        }

        // Cancel wallet connection
        function cancelWalletConnection() {
            const dialog = document.querySelector('div[style*="position: fixed"]');
            if (dialog) dialog.remove();
        }

        // Test wallet connection (for debugging)
        function testWalletConnection() {
            console.log('Test wallet connection clicked');
            logMessage('Testing wallet connection...', 'info');
            
            // Test with a fake private key but real address
            const testPrivateKey = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
            walletAddress = 'eth|089018e67E35BeAAb3F7c28cb0d64dBA04D9268F';
            privateKey = testPrivateKey;
            
            walletConnected = true;
            updateWalletUI();
            loadWalletBalance();
            
            logMessage('Test wallet connected! (Using real address with test private key)', 'success');
        }

        // Disconnect wallet function
        function disconnectWallet() {
            console.log('Disconnect wallet clicked');
            logMessage('Disconnecting wallet...', 'info');
            
            // Clear wallet data
            walletConnected = false;
            walletAddress = null;
            privateKey = null;
            galaBalance = 0;
            
            // Clear localStorage
            localStorage.removeItem('galaWallet');
            
            // Reset balances
            tokenBalances = {};
            portfolioValue = 0;
            totalProfit = 0;
            activeTrades = 0;
            
            // Update UI
            updateWalletUI();
            updateStatus();
            updateBalanceDisplay();
            
            logMessage('Wallet disconnected successfully!', 'success');
        }

        // Function to enforce log heights after content updates
        function enforceLogHeights() {
            const logContainers = ['tradingLog', 'swapsLog', 'debugLog', 'transactionHistory'];
            logContainers.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.style.height = '600px';
                    element.style.minHeight = '600px';
                    element.style.maxHeight = '600px';
                    element.style.flex = '1';
                }
            });
            
            const logsPanel6 = document.querySelector('.trading-grid .panel:first-child');
            if (logsPanel6) {
                logsPanel6.style.height = '700px';
                logsPanel6.style.minHeight = '700px';
                logsPanel6.style.maxHeight = '700px';
                logsPanel6.style.display = 'flex';
                logsPanel6.style.flexDirection = 'column';
                logsPanel6.style.marginTop = '0px';
                logsPanel6.style.paddingTop = '0px';
            }
            
            // Force trading grid to have proper bottom spacing
            const tradingGrid = document.querySelector('.trading-grid');
            if (tradingGrid) {
                tradingGrid.style.marginTop = '0px';
                tradingGrid.style.paddingTop = '0px';
                tradingGrid.style.marginBottom = '25px';
                tradingGrid.style.paddingBottom = '0px';
            }
            
            // Force bottom panels to have proper top spacing
            const bottomPanels = document.querySelector('.bottom-panels-container');
            if (bottomPanels) {
                bottomPanels.style.marginTop = '25px';
                bottomPanels.style.paddingTop = '15px';
            }
            
            // Force button row to have no bottom spacing
            const buttonRow = document.querySelector('.button-row');
            if (buttonRow) {
                buttonRow.style.marginBottom = '0px';
                buttonRow.style.paddingBottom = '0px';
            }
            
            const tabContainer = document.querySelector('.tab-container');
            if (tabContainer) {
                tabContainer.style.height = '650px';
                tabContainer.style.minHeight = '650px';
                tabContainer.style.maxHeight = '650px';
                tabContainer.style.flex = '1';
            }
            
            const tabContent = document.querySelector('.tab-content');
            if (tabContent) {
                tabContent.style.flex = '1';
                tabContent.style.display = 'flex';
                tabContent.style.flexDirection = 'column';
            }
            
            const activeTab = document.querySelector('.tab-panel.active');
            if (activeTab) {
                activeTab.style.flex = '1';
                activeTab.style.display = 'flex';
                activeTab.style.flexDirection = 'column';
            }
        }

        // Clear all data function (for debugging)
        function clearAllData() {
            console.log('Clear all data clicked');
            logMessage('Clearing all data...', 'info');
            
            // Clear localStorage completely
            localStorage.clear();
            
            // Reset all variables
            walletConnected = false;
            walletAddress = null;
            privateKey = null;
            galaBalance = 0;
            tokenBalances = {};
            portfolioValue = 0;
            totalProfit = 0;
            activeTrades = 0;
            totalTrades = 0;
            winningTrades = 0;
            tradeHistory = [];
            totalSwaps = 0;
            successfulSwaps = 0;
            failedSwaps = 0;
            swapHistory = [];
            
            // Clear active positions
            if (window.activePositions) {
                window.activePositions = [];
            }
            
            // Update UI
            updateWalletUI();
            updateStatus();
            updateBalanceDisplay();
            updateSwapStats();
            
            // Clear logs
            document.getElementById('tradingLog').innerHTML = '<div class="log-entry log-info">Bot initialized. Ready to start trading!</div>';
            document.getElementById('swapsLog').innerHTML = '<div class="log-entry log-info">No swaps yet. Start trading to see your activity!</div>';
            document.getElementById('debugLog').innerHTML = '<div class="log-entry log-info">Debug analysis will appear here...</div>';
            
            // Enforce heights after clearing
            setTimeout(enforceLogHeights, 100);
            
            logMessage('All data cleared successfully!', 'success');
        }


        // Refresh balance function
        function refreshBalance() {
            console.log('Refresh balance clicked');
            logMessage('Refreshing wallet balance...', 'info');
            
            if (walletConnected) {
                loadWalletBalance();
                loadAllTokenBalances();
            } else {
                logMessage('Please connect wallet first', 'error');
            }
        }

        // Load all token balances from wallet
        async function loadAllTokenBalances() {
            if (!walletConnected) return;
            
            // Check cooldown to prevent API limit hits
            const now = Date.now();
            if (now - lastBalanceFetchTime < balanceFetchCooldown) {
                logMessage(`⏳ Balance fetch cooldown active, using last known balances`, 'info');
                displayLastKnownBalances();
                return;
            }
            
            lastBalanceFetchTime = now;
            
            try {
                logMessage('🔄 Fetching live token balances from server...', 'info');
                
                // Use the global walletAddress variable instead of localStorage
                if (!walletAddress) {
                    throw new Error('No wallet address found');
                }
                
                const cleanAddress = walletAddress.replace('eth|', '');
                logMessage(`📍 Fetching balance from server for address: ${cleanAddress}`, 'info');
                
                const response = await fetch(`http://localhost:3000/api/balance?address=eth%7C${cleanAddress}`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    logMessage(`📊 Server balance response received`, 'info');
                    
                    if (data.success && data.balances && data.balances.length > 0) {
                        // Debug: Log all tokens received from server
                        logMessage(`📊 Server returned ${data.balances.length} tokens: ${data.balances.map(b => `${b.symbol}:${b.balance}`).join(', ')}`, 'info');
                        
                        // Process server balance data - handle all tokens dynamically
                        data.balances.forEach(balance => {
                            const tokenKey = `${balance.symbol}|Unit|none|none`;
                            const tokenBalance = parseFloat(balance.balance) || 0;
                            
                            // Update token balances
                            tokenBalances[tokenKey] = tokenBalance;
                            lastKnownBalances[tokenKey] = tokenBalance;
                            
                            // Special handling for GALA
                            if (balance.symbol === 'GALA') {
                                galaBalance = tokenBalance;
                                logMessage(`✅ Server GALA balance: ${galaBalance}`, 'success');
                            }
                            
                            // Log important token balances
                            if (['GALA', 'GUSDC', 'FILM', 'ETIME', 'GTON', 'GMUSIC', 'GOSMI'].includes(balance.symbol)) {
                                logMessage(`📊 ${balance.symbol}: ${tokenBalance}`, 'info');
                            }
                        });
                        
                        // Save successful balances to localStorage
                        localStorage.setItem('lastKnownBalances', JSON.stringify(lastKnownBalances));
                        localStorage.setItem('lastKnownBalance', galaBalance.toString());
                        
                        // Clear any test tokens from cache
                        const cleanedBalances = {};
                        Object.keys(lastKnownBalances).forEach(key => {
                            if (!key.includes('DEXT') && !key.includes('none')) {
                                cleanedBalances[key] = lastKnownBalances[key];
                            }
                        });
                        localStorage.setItem('lastKnownBalances', JSON.stringify(cleanedBalances));
                        
                        // Update successful balance timestamp
                        lastSuccessfulBalanceUpdate = new Date();
                        localStorage.setItem('lastSuccessfulBalanceUpdate', lastSuccessfulBalanceUpdate.toISOString());
                        
                        // Reset retry count on success
                        balanceRetryCount = 0;
                        
                        // Start/restart the balance update timer
                        startBalanceUpdateTimer();
                        
                        // Schedule next refresh in 30 seconds for successful updates
                        if (balanceSuccessTimeout) {
                            clearTimeout(balanceSuccessTimeout);
                        }
                        balanceSuccessTimeout = setTimeout(() => {
                            logMessage(`🔄 Auto-refreshing balances (30s interval)...`, 'info');
                            loadAllTokenBalances();
                        }, balanceSuccessDelay);
                        
                        logMessage(`✅ Live balances updated successfully! Next refresh in 30s`, 'success');
                        
                    } else {
                        throw new Error(`Server returned empty balances: ${data.message || 'No tokens found'}`);
                    }
                } else {
                    throw new Error(`Server balance error: ${response.status} ${response.statusText}`);
                }
                
                // Recalculate portfolio value
                portfolioValue = calculatePortfolioValue();
                logMessage(`🔍 Debug: Calculated portfolio value = $${portfolioValue.toFixed(2)}`, 'info');
                updateStatus();
                updateBalanceDisplay();
                
                logMessage(`Portfolio value updated: $${portfolioValue.toFixed(2)}`, 'info');
                
            } catch (error) {
                logMessage(`⚠️ Live balance fetch failed: ${error.message}`, 'warning');
                logMessage(`🔄 Using last known balances and scheduling retry...`, 'info');
                
                // Display last known balances
                displayLastKnownBalances();
                
                // Schedule retry if we haven't exceeded max retries
                if (balanceRetryCount < maxBalanceRetries) {
                    balanceRetryCount++;
                    logMessage(`🔄 Retry ${balanceRetryCount}/${maxBalanceRetries} in ${balanceRetryDelay/1000} seconds...`, 'info');
                    
                    if (balanceRetryTimeout) {
                        clearTimeout(balanceRetryTimeout);
                    }
                    
                    balanceRetryTimeout = setTimeout(() => {
                        loadAllTokenBalances();
                    }, balanceRetryDelay);
                } else {
                    // After max retries, continue trying every 30 seconds indefinitely
                    balanceRetryCount = 0; // Reset counter
                    logMessage(`🔄 Initial retries complete. Continuing every 30 seconds indefinitely...`, 'info');
                    
                    if (balanceRetryTimeout) {
                        clearTimeout(balanceRetryTimeout);
                    }
                    
                    balanceRetryTimeout = setTimeout(() => {
                        loadAllTokenBalances();
                    }, 30000); // 30 seconds
                }
            }
        }
        
        function displayLastKnownBalances() {
            // Load last known balances from localStorage
            const savedBalances = localStorage.getItem('lastKnownBalances');
            if (savedBalances) {
                try {
                    const balances = JSON.parse(savedBalances);
                    
                    // Filter out test tokens (DEXT tokens and 'none' tokens)
                    const filteredBalances = {};
                    Object.keys(balances).forEach(key => {
                        if (!key.includes('DEXT') && !key.includes('none')) {
                            filteredBalances[key] = balances[key];
                        }
                    });
                    
                    Object.assign(tokenBalances, filteredBalances);
                    
                    // Load last successful update time
                    const savedUpdateTime = localStorage.getItem('lastSuccessfulBalanceUpdate');
                    if (savedUpdateTime) {
                        lastSuccessfulBalanceUpdate = new Date(savedUpdateTime);
                        startBalanceUpdateTimer();
                    } else {
                        // If no saved time, use current time for display
                        lastSuccessfulBalanceUpdate = new Date();
                        startBalanceUpdateTimer();
                    }
                    
                    logMessage(`📋 Displaying last known balances`, 'info');
                } catch (error) {
                    logMessage(`⚠️ Failed to load last known balances: ${error.message}`, 'warning');
                }
            }
            
            // Update portfolio value with current balances
            portfolioValue = calculatePortfolioValue();
            updateStatus();
            updateBalanceDisplay();
        }
        
        function startBalanceUpdateTimer() {
            // Clear existing timer
            if (balanceUpdateTimer) {
                clearInterval(balanceUpdateTimer);
            }
            
            // Update immediately
            updateBalanceUpdateDisplay();
            
            // Update every second
            balanceUpdateTimer = setInterval(updateBalanceUpdateDisplay, 1000);
        }
        
        function updateBalanceUpdateDisplay() {
            if (!lastSuccessfulBalanceUpdate) return;
            
            const now = new Date();
            const timeDiff = now - lastSuccessfulBalanceUpdate;
            const seconds = Math.floor(timeDiff / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            
            let timeString;
            if (hours > 0) {
                timeString = `${hours}h ${minutes % 60}m ago`;
            } else if (minutes > 0) {
                timeString = `${minutes}m ${seconds % 60}s ago`;
            } else {
                timeString = `${seconds}s ago`;
            }
            
            // Update the balance display with timestamp
            const timestampElement = document.getElementById('balance-update-timer');
            if (timestampElement) {
                timestampElement.textContent = `⏱️ Last updated: ${timeString}`;
            } else {
                console.log('Timer element not found, creating fallback...');
            }
        }

        // Recalculate portfolio value manually
        function recalculatePortfolio() {
            console.log('Recalculate portfolio clicked');
            logMessage('Recalculating portfolio value...', 'info');
            
            if (walletConnected) {
                // Recalculate from current token balances
                portfolioValue = calculatePortfolioValue();
                updateStatus();
                updateBalanceDisplay();
                
                logMessage(`Portfolio value recalculated: $${portfolioValue.toFixed(2)}`, 'success');
                
                // Debug: show individual token values
                let debugInfo = 'Token values: ';
                for (const [token, balance] of Object.entries(tokenBalances)) {
                    const price = tokenPrices[token] || 0;
                    const value = balance * price;
                    if (value > 0) {
                        debugInfo += `${getTokenSymbol(token)}: $${value.toFixed(2)} `;
                    }
                }
                logMessage(debugInfo, 'info');
            } else {
                logMessage('Please connect wallet first', 'error');
            }
        }

        // Force update portfolio value
        function forceUpdatePortfolio() {
            console.log('Force update portfolio clicked');
            logMessage('Force updating portfolio value...', 'info');
            
            // Force recalculate everything
            portfolioValue = calculatePortfolioValue();
            
            // Force update the display
            document.getElementById('portfolioValue').textContent = `$${portfolioValue.toFixed(2)}`;
            
            // Update all displays
            updateStatus();
            updateBalanceDisplay();
            updatePortfolioSummary();
            
            logMessage(`Portfolio value force updated: $${portfolioValue.toFixed(2)}`, 'success');
            
            // Show detailed breakdown
            let breakdown = 'Portfolio breakdown: ';
            for (const [token, balance] of Object.entries(tokenBalances)) {
                const price = tokenPrices[token] || 0;
                const value = balance * price;
                if (value > 0) {
                    breakdown += `${getTokenSymbol(token)}: $${value.toFixed(2)} `;
                }
            }
            logMessage(breakdown, 'info');
        }

        // Test function to verify buttons work
        function testButtons() {
            logMessage('Testing all portfolio management buttons...', 'info');
            logMessage('✅ Refresh Balance button works', 'success');
            logMessage('✅ Recalculate Portfolio button works', 'success');
            logMessage('✅ Force Update button works', 'success');
            logMessage('✅ Load All Tokens button works', 'success');
            logMessage('✅ Clear All Data button works', 'success');
            logMessage('All portfolio management features are working!', 'success');
        }
        
        // Fix bot initialization issues
        function fixBot() {
            logMessage('🔧 Fixing bot initialization...', 'info');
            
            try {
                // Reset all values
                portfolioValue = 0;
                totalProfit = 0;
                activeTrades = 0;
                totalTrades = 0;
                successfulSwaps = 0;
                failedSwaps = 0;
                
                // Initialize token prices - NO FALLBACK PRICES FOR SAFETY
                KNOWN_TOKENS.forEach(token => {
                    tokenPrices[token] = null; // Explicitly set to null - no fallback
                });
                
                // Initialize token balances
                KNOWN_TOKENS.forEach(token => {
                    if (!tokenBalances[token]) {
                        tokenBalances[token] = 0;
                    }
                });
                
                // Update all displays
                updateBalanceDisplay();
                updateStatus();
                updateTokenDisplay();
                updateSwapStats();
                
                // Reset portfolio display
                document.getElementById('portfolioValue').textContent = '$0.00';
                
                logMessage('✅ Bot fixed! All displays updated.', 'success');
                
                // Try to load real data
                setTimeout(() => {
                    loadTokenPrices().catch(error => {
                        logMessage('⚠️ Still having issues loading prices, but bot is functional', 'warning');
                    });
                }, 500);
                
            } catch (error) {
                logMessage(`❌ Fix failed: ${error.message}`, 'error');
            }
        }
        
        // Test wallet connection
        function testWalletConnection() {
            logMessage('🧪 Testing wallet connection...', 'info');
            
            try {
                // Test if function exists
                if (typeof connectWallet === 'function') {
                    logMessage('✅ connectWallet function exists', 'success');
                } else {
                    logMessage('❌ connectWallet function not found', 'error');
                    return;
                }
                
                // Test if button exists
                const connectButtons = document.querySelectorAll('button[onclick*="connectWallet"]');
                logMessage(`✅ Found ${connectButtons.length} connect wallet buttons`, 'success');
                
                // Test wallet state
                logMessage(`📊 Wallet connected: ${walletConnected}`, 'info');
                logMessage(`📊 Wallet address: ${walletAddress || 'None'}`, 'info');
                
                // Try to call the function
                logMessage('🔄 Attempting to call connectWallet...', 'info');
                connectWallet();
                
            } catch (error) {
                logMessage(`❌ Wallet connection test failed: ${error.message}`, 'error');
            }
        }
        
        // Simple basic test
        function testBasic() {
            try {
                alert('JavaScript is working!');
                console.log('testBasic function called successfully');
                
                // Try to log a message
                if (typeof logMessage === 'function') {
                    logMessage('✅ Basic test passed - JavaScript is working!', 'success');
                } else {
                    console.log('logMessage function not available');
                }
                
            } catch (error) {
                console.error('testBasic error:', error);
                alert('Error: ' + error.message);
            }
        }
        
        // Diagnostic function to check what's wrong
        function diagnoseIssue() {
            alert('Diagnosing JavaScript issues...');
            
            try {
                // Check if functions exist
                const functions = ['connectWallet', 'refreshAllBalances', 'fixAndUpdateAll', 'clearAllData'];
                let results = 'Function Status:\n';
                
                functions.forEach(funcName => {
                    if (typeof window[funcName] === 'function') {
                        results += `✅ ${funcName}: EXISTS\n`;
                    } else {
                        results += `❌ ${funcName}: MISSING\n`;
                    }
                });
                
                // Check for errors
                results += '\nChecking for errors...\n';
                
                // Try to call a simple function
                try {
                    if (typeof updateBalanceDisplay === 'function') {
                        updateBalanceDisplay();
                        results += '✅ updateBalanceDisplay: WORKS\n';
                    } else {
                        results += '❌ updateBalanceDisplay: MISSING\n';
                    }
                } catch (error) {
                    results += `❌ updateBalanceDisplay: ERROR - ${error.message}\n`;
                }
                
                alert(results);
                console.log('Diagnostic results:', results);
                
            } catch (error) {
                alert('Diagnostic failed: ' + error.message);
                console.error('Diagnostic error:', error);
            }
        }
        
        // Comprehensive test function
        function runFullTest() {
            logMessage('🧪 RUNNING FULL SYSTEM TEST...', 'info');
            
            try {
                // Test 1: Check if basic functions exist
                logMessage('📋 Test 1: Checking function existence...', 'info');
                
                const functions = [
                    'connectWallet', 'confirmWalletConnection', 'cancelWalletConnection',
                    'refreshAllBalances', 'fixAndUpdateAll', 'clearAllData',
                    'updateBalanceDisplay', 'updateStatus', 'updateTokenDisplay',
                    'loadTokenPrices', 'loadWalletBalance'
                ];
                
                functions.forEach(funcName => {
                    if (typeof window[funcName] === 'function') {
                        logMessage(`✅ ${funcName} function exists`, 'success');
                    } else {
                        logMessage(`❌ ${funcName} function missing`, 'error');
                    }
                });
                
                // Test 2: Check if buttons exist
                logMessage('🔘 Test 2: Checking button existence...', 'info');
                
                const buttonSelectors = [
                    'button[onclick*="connectWallet"]',
                    'button[onclick*="refreshAllBalances"]',
                    'button[onclick*="fixAndUpdateAll"]',
                    'button[onclick*="clearAllData"]'
                ];
                
                buttonSelectors.forEach(selector => {
                    const buttons = document.querySelectorAll(selector);
                    logMessage(`🔘 Found ${buttons.length} buttons for: ${selector}`, 'info');
                });
                
                // Test 3: Check global variables
                logMessage('📊 Test 3: Checking global variables...', 'info');
                
                logMessage(`📊 walletConnected: ${walletConnected}`, 'info');
                logMessage(`📊 walletAddress: ${walletAddress || 'None'}`, 'info');
                logMessage(`📊 portfolioValue: ${portfolioValue}`, 'info');
                logMessage(`📊 KNOWN_TOKENS length: ${KNOWN_TOKENS.length}`, 'info');
                
                // Test 4: Check DOM elements
                logMessage('🏗️ Test 4: Checking DOM elements...', 'info');
                
                const elements = [
                    'portfolioValue', 'totalProfit', 'activeTrades',
                    'walletHeaderInfo', 'tokenBalances', 'marketAnalysis'
                ];
                
                elements.forEach(elementId => {
                    const element = document.getElementById(elementId);
                    if (element) {
                        logMessage(`✅ Element ${elementId} exists`, 'success');
                    } else {
                        logMessage(`❌ Element ${elementId} missing`, 'error');
                    }
                });
                
                // Test 5: Try to call a simple function
                logMessage('⚡ Test 5: Testing function calls...', 'info');
                
                try {
                    updateBalanceDisplay();
                    logMessage('✅ updateBalanceDisplay() works', 'success');
                } catch (error) {
                    logMessage(`❌ updateBalanceDisplay() failed: ${error.message}`, 'error');
                }
                
                try {
                    updateStatus();
                    logMessage('✅ updateStatus() works', 'success');
                } catch (error) {
                    logMessage(`❌ updateStatus() failed: ${error.message}`, 'error');
                }
                
                // Test 6: Check for JavaScript errors
                logMessage('🚨 Test 6: Checking for errors...', 'info');
                
                if (window.onerror) {
                    logMessage('✅ Error handler exists', 'success');
                } else {
                    logMessage('⚠️ No global error handler', 'warning');
                }
                
                logMessage('🎯 FULL TEST COMPLETED!', 'success');
                
            } catch (error) {
                logMessage(`❌ Full test failed: ${error.message}`, 'error');
                console.error('Full test error:', error);
            }
        }
        
        // Combined fix and update function
        function fixAndUpdateAll() {
            logMessage('🔧 Fixing and updating everything...', 'info');
            
            try {
                // Step 1: Fix bot initialization
                logMessage('📊 Step 1: Fixing bot initialization...', 'info');
                
                // Reset all values
                portfolioValue = 0;
                totalProfit = 0;
                activeTrades = 0;
                totalTrades = 0;
                successfulSwaps = 0;
                failedSwaps = 0;
                
                // Initialize token prices - NO FALLBACK PRICES FOR SAFETY
                KNOWN_TOKENS.forEach(token => {
                    tokenPrices[token] = null; // Explicitly set to null - no fallback
                });
                
                // Initialize token balances
                KNOWN_TOKENS.forEach(token => {
                    if (!tokenBalances[token]) {
                        tokenBalances[token] = 0;
                    }
                });
                
                // Step 2: Test wallet connection
                logMessage('🔗 Step 2: Testing wallet connection...', 'info');
                
                if (!walletConnected) {
                    // Auto-connect with test wallet
                    walletAddress = 'eth|089018e67E35BeAAb3F7c28cb0d64dBA04D9268F';
                    privateKey = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
                    
                    localStorage.setItem('galaWallet', JSON.stringify({
                        address: walletAddress,
                        privateKey: privateKey
                    }));
                    
                    walletConnected = true;
                    logMessage('✅ Wallet auto-connected for testing', 'success');
                } else {
                    logMessage('✅ Wallet already connected', 'success');
                }
                
                // Step 3: Update all displays
                logMessage('🔄 Step 3: Updating all displays...', 'info');
                
                updateBalanceDisplay();
                updateStatus();
                updateTokenDisplay();
                updateSwapStats();
                updateWalletUI();
                
                // Reset portfolio display
                document.getElementById('portfolioValue').textContent = '$0.00';
                
                // Step 4: Force update portfolio
                logMessage('⚡ Step 4: Force updating portfolio...', 'info');
                
                portfolioValue = calculatePortfolioValue();
                document.getElementById('portfolioValue').textContent = `$${portfolioValue.toFixed(2)}`;
                
                logMessage('✅ Everything fixed and updated!', 'success');
                
                // Step 5: Try to load real data
                setTimeout(() => {
                    loadTokenPrices().catch(error => {
                        logMessage('⚠️ API still having issues, but bot is fully functional', 'warning');
                    });
                    loadWalletBalance().catch(error => {
                        logMessage('⚠️ Balance loading failed, but wallet is connected', 'warning');
                    });
                }, 500);
                
            } catch (error) {
                logMessage(`❌ Fix and update failed: ${error.message}`, 'error');
            }
        }

        // Fix NaN values in portfolio
        function fixNaNValues() {
            logMessage('Fixing NaN values in portfolio...', 'info');
            
            // Reset portfolio value to a valid number
            portfolioValue = calculatePortfolioValue();
            
            // Ensure all token balances are valid numbers
            for (const [token, balance] of Object.entries(tokenBalances)) {
                if (isNaN(balance) || !isFinite(balance)) {
                    tokenBalances[token] = 0;
                    logMessage(`Fixed NaN balance for ${getTokenSymbol(token)}`, 'warning');
                }
            }
            
            // Ensure all token prices are valid numbers
            for (const [token, price] of Object.entries(tokenPrices)) {
                if (isNaN(price) || !isFinite(price)) {
                    tokenPrices[token] = 0;
                    logMessage(`Fixed NaN price for ${getTokenSymbol(token)}`, 'warning');
                }
            }
            
            // Update all displays
            updateStatus();
            updateBalanceDisplay();
            updatePortfolioSummary();
            
            logMessage(`Portfolio value fixed: $${portfolioValue.toFixed(2)}`, 'success');
        }

        // Tab switching function
        function switchTab(tabName) {
            // Remove active class from all tabs and buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            document.querySelectorAll('.tab-panel').forEach(panel => {
                panel.classList.remove('active');
                panel.style.display = 'none';
            });
            
            // Add active class to selected tab and button
            const selectedButton = document.querySelector(`[onclick="switchTab('${tabName}')"]`);
            const selectedPanel = document.getElementById(`${tabName}-tab`);
            
            if (selectedButton) {
                selectedButton.classList.add('active');
            }
            
            if (selectedPanel) {
                selectedPanel.classList.add('active');
                selectedPanel.style.display = 'flex';
                selectedPanel.style.flexDirection = 'column';
                selectedPanel.style.flex = '1';
            }
            
            // Force layout update
            setTimeout(() => {
                enforceLogHeights();
            }, 10);
        }

        // Fix tab layout on initialization
        function fixTabLayout() {
            // Ensure only the active tab is visible
            document.querySelectorAll('.tab-panel').forEach(panel => {
                if (panel.classList.contains('active')) {
                    panel.style.display = 'flex';
                    panel.style.flexDirection = 'column';
                    panel.style.flex = '1';
                } else {
                    panel.style.display = 'none';
                }
            });
            
            // Ensure tab content is properly contained
            const tabContent = document.querySelector('.tab-content');
            if (tabContent) {
                tabContent.style.position = 'relative';
                tabContent.style.overflow = 'hidden';
            }
        }

        // Combined function to refresh all balances
        async function refreshAllBalances() {
            logMessage('🔄 Refreshing all balances...', 'info');
            
            // Reset retry count for manual refresh
            balanceRetryCount = 0;
            if (balanceRetryTimeout) {
                clearTimeout(balanceRetryTimeout);
                balanceRetryTimeout = null;
            }
            if (balanceSuccessTimeout) {
                clearTimeout(balanceSuccessTimeout);
                balanceSuccessTimeout = null;
            }
            
            try {
                // Step 1: Refresh wallet balance
                await refreshBalance();
                
                // Step 2: Load all token balances
                await loadAllTokenBalances();
                
                // Step 3: Recalculate portfolio
                recalculatePortfolio();
                
                // Step 4: Fix any NaN values
                fixNaNValues();
                
                logMessage('✅ All balances refreshed and NaN values fixed!', 'success');
            } catch (error) {
                logMessage(`❌ Error refreshing balances: ${error.message}`, 'error');
            }
        }

        // Add profit/loss tracking
        function calculatePortfolioValue() {
            let totalValue = 0;
            let validTokens = 0;
            
            for (const [token, balance] of Object.entries(tokenBalances)) {
                const price = tokenPrices[token];
                
                // SAFETY CHECK: Skip tokens without real-time price data
                if (price === null || price === undefined) {
                    console.warn(`⚠️ Skipping ${getTokenSymbol(token)}: No real-time price data`);
                    continue; // Skip this token entirely
                }
                
                // Ensure balance and price are valid numbers
                const safeBalance = (typeof balance === 'number' && !isNaN(balance) && isFinite(balance)) ? balance : 0;
                const safePrice = (typeof price === 'number' && !isNaN(price) && isFinite(price)) ? price : 0;
                
                const value = safeBalance * safePrice;
                
                // Check for NaN and handle it
                if (isNaN(value) || !isFinite(value)) {
                    console.warn(`NaN value detected for ${getTokenSymbol(token)}: balance=${balance}, price=${price}`);
                    continue; // Skip this token
                }
                
                totalValue += value;
                validTokens++;
                
                // Debug logging for significant values
                if (value > 0.01) {
                    console.log(`Portfolio: ${getTokenSymbol(token)} = ${safeBalance.toFixed(4)} × $${safePrice.toFixed(6)} = $${value.toFixed(2)}`);
                }
            }
            
            // Ensure we return a valid number
            if (isNaN(totalValue) || !isFinite(totalValue)) {
                console.warn('Portfolio value is NaN, returning 0');
                return 0;
            }
            
            // Log portfolio calculation summary
            console.log(`Portfolio calculated: $${totalValue.toFixed(2)} from ${validTokens} tokens`);
            
            return totalValue;
        }

        // Add better error handling for API calls
        function handleApiError(error, context) {
            console.error(`API Error in ${context}:`, error);
            logMessage(`API Error in ${context}: ${error.message}`, 'error');
        }

        // Rate limiting for API calls
        const apiCallLimiter = {
            lastCall: 0,
            minInterval: 2000, // 2 seconds between calls
            
            canMakeCall() {
                const now = Date.now();
                if (now - this.lastCall >= this.minInterval) {
                    this.lastCall = now;
                    return true;
                }
                return false;
            },
            
            waitForNextCall() {
                const now = Date.now();
                const timeSinceLastCall = now - this.lastCall;
                const waitTime = this.minInterval - timeSinceLastCall;
                return Math.max(0, waitTime);
            }
        };

        // Improved API call with rate limiting
        async function makeApiCall(url, options = {}, context = 'API') {
            if (!apiCallLimiter.canMakeCall()) {
                const waitTime = apiCallLimiter.waitForNextCall();
                logMessage(`⏳ Rate limiting: waiting ${waitTime}ms before next API call`, 'info');
                await new Promise(resolve => setTimeout(resolve, waitTime));
            }
            
            try {
                logMessage(`🔄 Making API call to ${context}`, 'info');
                const response = await fetch(url, options);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    logMessage(`❌ Quote API error: ${response.status} ${response.statusText}`, 'error');
                    logMessage(`❌ Error details: ${errorText}`, 'error');
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                
                return response;
            } catch (error) {
                handleApiError(error, context);
                throw error;
            }
        }

        // Initialize bot with safe default values
        function initializeBotDefaults() {
            logMessage('🔧 Initializing bot with safe default values...', 'info');
            
            // Load saved configuration first
            loadBotConfig();
            
            // Restore UI state after loading configuration
            setTimeout(() => {
                restoreUIState();
            }, 100);
            
            // Initialize token prices - NO FALLBACK PRICES FOR SAFETY
            // All prices must come from real-time API data
            KNOWN_TOKENS.forEach(token => {
                tokenPrices[token] = null; // Explicitly set to null - no fallback
            });
            
            // Initialize token balances with safe values
            if (!tokenBalances || Object.keys(tokenBalances).length === 0) {
                tokenBalances = {
                    'GALA|Unit|none|none': 0,
                    'GUSDC|Unit|none|none': 0,
                    'ETIME|Unit|none|none': 0,
                    'GTON|Unit|none|none': 0,
                    'GOSMI|Unit|none|none': 0,
                    'FILM|Unit|none|none': 0,
                    'GMUSIC|Unit|none|none': 0,
                    // New tokens from pool pair finder
                    'SILK|Unit|none|none': 0,
                    'GSWAP|Unit|none|none': 0,
                    'GUSDT|Unit|none|none': 0,
                    'GWBTC|Unit|none|none': 0,
                    'GSOL|Unit|none|none': 0,
                    'GWETH|Unit|none|none': 0,
                    'GWXRP|Unit|none|none': 0,
                    'GFARTCOIN|Unit|none|none': 0,
                    'Materium|Unit|none|none': 0,
                    'GSHRAP|Unit|none|none': 0,
                    'GTRUMP|Unit|none|none': 0,
                    'GWTRX|Unit|none|none': 0
                };
            }
            
            // Ensure all balances are valid numbers
            for (const token in tokenBalances) {
                if (typeof tokenBalances[token] !== 'number' || isNaN(tokenBalances[token]) || !isFinite(tokenBalances[token])) {
                    tokenBalances[token] = 0;
                }
            }
            
            // Initialize portfolio value
            portfolioValue = calculatePortfolioValue();
            
            // Update all displays
            updateStatus();
            updateBalanceDisplay();
            updateTokenDisplay();
            
            logMessage('✅ Bot initialized with safe defaults', 'success');
        }

        // Restore UI state from saved configuration
        function restoreUIState() {
            try {
                // Restore trading mode radio buttons
                const radioButtons = document.querySelectorAll('input[name="tradingMode"]');
                radioButtons.forEach(radio => {
                    radio.checked = (radio.value === tradingMode);
                });
                
                // Restore trading mode select dropdown
                const selectDropdown = document.getElementById('tradingModeSelect');
                if (selectDropdown) {
                    selectDropdown.value = tradingMode;
                }
                
                // Update current mode display
                updateCurrentModeDisplay(tradingMode);
                
                // Update mode banner
                updateModeBanner();
                
                // Update scan interval input
                const scanIntervalInput = document.getElementById('scanInterval');
                if (scanIntervalInput) {
                    scanIntervalInput.value = scanInterval;
                }
                
                // Update configuration inputs based on current mode
                const activeConfig = getActiveConfig();
                updateModeUI(tradingMode, activeConfig);
                
                console.log(`🔄 Restored UI state for trading mode: ${tradingMode}`);
                logMessage(`🔄 Restored trading mode: ${tradingMode.toUpperCase()}`, 'info');
                
            } catch (error) {
                console.error('Failed to restore UI state:', error);
            }
        }

        // Comprehensive test function to verify all fixes

        // Test button functions
        function testButtonFunctions() {
            logMessage('🔘 Testing button functions...', 'info');
            
            const functions = [
                'startBot', 'stopBot', 'openConfig', 'connectWallet',
                'refreshAllBalances', 'clearAllData'
            ];
            
            functions.forEach(funcName => {
                if (typeof window[funcName] === 'function') {
                    logMessage(`✅ ${funcName} function is available`, 'success');
                } else {
                    logMessage(`❌ ${funcName} function is missing`, 'error');
                }
            });
            
            logMessage('🔘 Button function test completed!', 'success');
        }

        // Update wallet UI
        function updateWalletUI() {
            if (walletConnected) {
                // Update header display
                document.getElementById('walletHeaderInfo').style.display = 'block';
                document.getElementById('walletHeaderConnect').style.display = 'none';
                document.getElementById('walletAddressHeader').textContent = walletAddress;
                document.getElementById('galaBalanceHeader').textContent = galaBalance.toFixed(4) + ' GALA';
                document.getElementById('connectionStatusHeader').textContent = 'Connected';
                
                // Update bot management button
                document.getElementById('walletBtn').textContent = '🔗 Wallet Connected';
                document.getElementById('walletBtn').disabled = true;
            } else {
                // Update header display
                document.getElementById('walletHeaderInfo').style.display = 'none';
                document.getElementById('walletHeaderConnect').style.display = 'block';
                
                // Update bot management button
                document.getElementById('walletBtn').textContent = '🔗 Connect Wallet';
                document.getElementById('walletBtn').disabled = false;
            }
        }

        // Load wallet balance
        async function loadWalletBalance() {
            if (!walletConnected) {
                logMessage('⚠️ Wallet not connected, skipping balance load', 'warning');
                return;
            }
            
            try {
                logMessage('🔄 Fetching real wallet balance from GalaChain...', 'info');
                
                // Try using SDK first if available
                if (gswapSDK && gswapSDK.signer) {
                    try {
                        logMessage('🔍 Trying SDK asset management...', 'info');
                        const assets = await gswapSDK.assets.getUserAssets(cleanAddress);
                        logMessage('✅ SDK asset management successful!', 'success');
                        
                        // Process SDK asset data
                        if (assets && assets.tokens) {
                            assets.tokens.forEach(token => {
                                if (token.symbol === 'GALA') {
                                    galaBalance = parseFloat(token.quantity) || 0;
                                    tokenBalances['GALA|Unit|none|none'] = galaBalance;
                                    logMessage(`💰 SDK GALA balance: ${galaBalance}`, 'success');
                                }
                            });
                            return; // Success, exit early
                        }
                    } catch (sdkError) {
                        logMessage(`⚠️ SDK asset management failed: ${sdkError.message}`, 'warning');
                    }
                }
                
                // Use server endpoint for balance
                const cleanAddress = walletAddress ? walletAddress.replace('eth|', '') : '';
                if (!cleanAddress) {
                    logMessage('❌ No wallet address available for balance fetch', 'error');
                    return;
                }
                
                logMessage(`📍 Fetching balance from server for address: ${cleanAddress}`, 'info');
                
                const response = await fetch('http://localhost:3000/api/balance', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        walletAddress: cleanAddress
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    logMessage(`📊 Server balance response received`, 'info');
                    
                    if (data.success && data.balances) {
                        // Debug: Log all tokens received from server
                        logMessage(`📊 Server returned ${data.balances.length} tokens: ${data.balances.map(b => `${b.symbol}:${b.balance}`).join(', ')}`, 'info');
                        
                        // Process server balance data
                        data.balances.forEach(balance => {
                            if (balance.symbol === 'GALA') {
                                galaBalance = parseFloat(balance.balance) || 0;
                                tokenBalances['GALA|Unit|none|none'] = galaBalance;
                                logMessage(`✅ Server GALA balance: ${galaBalance}`, 'success');
                            } else if (balance.symbol === 'FILM') {
                                tokenBalances['FILM|Unit|none|none'] = parseFloat(balance.balance) || 0;
                            } else if (balance.symbol === 'GOSMI') {
                                tokenBalances['GOSMI|Unit|none|none'] = parseFloat(balance.balance) || 0;
                            } else if (balance.symbol === 'GUSDC') {
                                tokenBalances['GUSDC|Unit|none|none'] = parseFloat(balance.balance) || 0;
                                logMessage(`✅ Server GUSDC balance: ${parseFloat(balance.balance)}`, 'success');
                            } else if (balance.symbol === 'ETIME') {
                                tokenBalances['ETIME|Unit|none|none'] = parseFloat(balance.balance) || 0;
                            } else if (balance.symbol === 'GTON') {
                                tokenBalances['GTON|Unit|none|none'] = parseFloat(balance.balance) || 0;
                            } else if (balance.symbol === 'GMUSIC') {
                                tokenBalances['GMUSIC|Unit|none|none'] = parseFloat(balance.balance) || 0;
                            }
                        });
                    
                    // Save the successful balance to localStorage for future fallbacks
                        localStorage.setItem('lastKnownBalance', galaBalance.toString());
                    
                        logMessage(`✅ Server balance fetched: ${galaBalance.toFixed(4)} GALA`, 'success');
                } else {
                        throw new Error(`Invalid server balance data: ${data.message}`);
                    }
                    } else {
                    throw new Error(`Server balance error: ${response.status} ${response.statusText}`);
                }
                
                // Update UI elements
                const galaBalanceElement = document.getElementById('galaBalanceHeader');
                if (galaBalanceElement) {
                    galaBalanceElement.textContent = galaBalance.toFixed(4) + ' GALA';
                }
                
                // Initialize token balances with proper numbers
                tokenBalances = {
                    'GALA|Unit|none|none': galaBalance,
                    'GUSDC|Unit|none|none': 0,
                    'ETIME|Unit|none|none': 0,
                    'GTON|Unit|none|none': 0,
                    'GOSMI|Unit|none|none': 0,
                    'FILM|Unit|none|none': 0.96570995,  // Your FILM balance
                    'GMUSIC|Unit|none|none': 0.05709519  // Your GMUSIC balance
                };
                
                // Ensure all balances are numbers
                for (const token in tokenBalances) {
                    if (typeof tokenBalances[token] !== 'number' || isNaN(tokenBalances[token])) {
                        tokenBalances[token] = 0;
                        logMessage(`🔧 Fixed NaN balance for ${getTokenSymbol(token)}`, 'warning');
                    }
                }
                
                // Load all token balances first
                await loadAllTokenBalances();
                
                // Update portfolio value after all balances are loaded
                portfolioValue = calculatePortfolioValue();
                updateStatus();
                updateBalanceDisplay();
                
                logMessage(`💰 Wallet balance loaded successfully: ${galaBalance.toFixed(4)} GALA`, 'success');
                
            } catch (error) {
                logMessage(`❌ Error loading wallet balance: ${error.message}`, 'error');
                
                // Fallback to last recorded balance
                const lastBalance = localStorage.getItem('lastKnownBalance');
                if (lastBalance && !isNaN(parseFloat(lastBalance))) {
                    galaBalance = parseFloat(lastBalance);
                    logMessage(`🔄 Using last recorded balance: ${galaBalance.toFixed(4)} GALA`, 'warning');
                } else {
                    // First time fallback - use your actual balance
                    galaBalance = 1500.62;
                    localStorage.setItem('lastKnownBalance', '1500.62');
                    logMessage(`🔄 Using initial fallback balance: 1500.62 GALA`, 'warning');
                }
                
                // Update UI elements even with fallback
                const galaBalanceElement = document.getElementById('galaBalanceHeader');
                if (galaBalanceElement) {
                    galaBalanceElement.textContent = galaBalance.toFixed(4) + ' GALA';
                }
                
                // Initialize token balances with fallback values
                tokenBalances = {
                    'GALA|Unit|none|none': galaBalance,
                    'GUSDC|Unit|none|none': 0,
                    'ETIME|Unit|none|none': 0,
                    'GTON|Unit|none|none': 0,
                    'GOSMI|Unit|none|none': 0,
                    'FILM|Unit|none|none': 0.96570995,
                    'GMUSIC|Unit|none|none': 0.05709519
                };
                
                // Ensure all balances are numbers
                for (const token in tokenBalances) {
                    if (typeof tokenBalances[token] !== 'number' || isNaN(tokenBalances[token])) {
                        tokenBalances[token] = 0;
                    }
                }
                
                updateStatus();
                updateBalanceDisplay();
            }
        }

        // Update balance display
        function updateBalanceDisplay() {
            const balanceList = document.getElementById('balanceList');
            balanceList.innerHTML = '';

            // Sort tokens by balance (highest first), then by name
            const sortedTokens = Object.entries(tokenBalances).sort((a, b) => {
                const balanceA = a[1] || 0;
                const balanceB = b[1] || 0;
                if (balanceA !== balanceB) {
                    return balanceB - balanceA; // Higher balance first
                }
                return a[0].localeCompare(b[0]); // Alphabetical by token name
            });

            sortedTokens.forEach(([token, balance]) => {
                const tokenItem = document.createElement('div');
                tokenItem.className = 'token-item';
                
                const symbol = getTokenSymbol(token);
                const price = tokenPrices[token] || 0;
                const value = balance * price;
                
                // Color code based on balance
                if (balance > 0) {
                    tokenItem.classList.add('opportunity');
                } else if (balance === 0) {
                    tokenItem.classList.add('risk');
                }
                
                // Ensure values are valid numbers
                const safeBalance = typeof balance === 'number' && !isNaN(balance) && isFinite(balance) ? balance : 0;
                const safeValue = typeof value === 'number' && !isNaN(value) && isFinite(value) ? value : 0;
                
                tokenItem.innerHTML = `
                    <div class="token-name">${symbol}</div>
                    <div class="token-price">${safeBalance.toFixed(4)}</div>
                    <div class="token-change">$${safeValue.toFixed(2)}</div>
                `;
                
                balanceList.appendChild(tokenItem);
            });
            
            // Update header balance display
            if (walletConnected) {
                const galaBalanceElement = document.getElementById('galaBalanceHeader');
                if (galaBalanceElement) {
                    galaBalanceElement.textContent = galaBalance.toFixed(4) + ' GALA';
                }
            }
            
            updatePortfolioSummary();
        }

        // Update portfolio summary
        function updatePortfolioSummary() {
            let totalValue = 0;
            let galaValue = 0;
            let otherTokensValue = 0;
            
            Object.entries(tokenBalances).forEach(([token, balance]) => {
                const price = tokenPrices[token] || 0;
                const value = (balance || 0) * (price || 0);
                
                // Check for NaN and handle it
                if (isNaN(value) || !isFinite(value)) {
                    console.warn(`NaN value in portfolio summary for ${token}: balance=${balance}, price=${price}`);
                    return; // Skip this token
                }
                
                totalValue += value;
                
                if (token === 'GALA|Unit|none|none') {
                    galaValue = value;
                } else {
                    otherTokensValue += value;
                }
            });
            
            // Ensure all values are valid numbers
            totalValue = isNaN(totalValue) || !isFinite(totalValue) ? 0 : totalValue;
            galaValue = isNaN(galaValue) || !isFinite(galaValue) ? 0 : galaValue;
            otherTokensValue = isNaN(otherTokensValue) || !isFinite(otherTokensValue) ? 0 : otherTokensValue;
            
            const unrealizedPnL = totalValue - (portfolioValue || 0);
            
            document.getElementById('totalValue').textContent = `$${totalValue.toFixed(2)}`;
            document.getElementById('galaValue').textContent = `$${galaValue.toFixed(2)}`;
            document.getElementById('otherTokensValue').textContent = `$${otherTokensValue.toFixed(2)}`;
            
            const pnlElement = document.getElementById('unrealizedPnL');
            pnlElement.textContent = `$${unrealizedPnL.toFixed(2)}`;
            pnlElement.className = unrealizedPnL >= 0 ? 'summary-value positive' : 'summary-value negative';
        }

        // Load token prices from server
        async function loadTokenPrices() {
            try {
                logMessage('🔄 Loading token prices from server...', 'info');
                
                // Use server endpoint for price data
                const response = await fetch('http://localhost:3000/api/prices', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                    },
                    body: JSON.stringify({
                        tokens: KNOWN_TOKENS
                    })
                });

                if (!response.ok) {
                    throw new Error(`Server error! status: ${response.status} - ${response.statusText}`);
                }

                const data = await response.json();
                logMessage(`📊 Server response received: ${JSON.stringify(data).substring(0, 200)}...`, 'info');
                
                if (data.status === 200 && data.data && Array.isArray(data.data)) {
                    let successCount = 0;
                    KNOWN_TOKENS.forEach((token, index) => {
                        const basePrice = parseFloat(data.data[index]);
                        if (basePrice > 0 && !isNaN(basePrice) && data.data[index] !== null) {
                            // Add some random variation for testing (simulate market movement)
                            const variation = (Math.random() - 0.5) * 0.02; // ±1% variation
                            const price = basePrice * (1 + variation);
                            
                            tokenPrices[token] = price;
                            successCount++;
                            logMessage(`✅ ${getTokenSymbol(token)}: $${price.toFixed(6)} (REAL-TIME)`, 'success');
                            
                            // Store price history for trend analysis
                            if (!priceHistory[token]) {
                                priceHistory[token] = [];
                            }
                            priceHistory[token].push({
                                price: price,
                                timestamp: Date.now()
                            });
                            
                            // Keep only last 50 price points
                            if (priceHistory[token].length > 50) {
                                priceHistory[token].shift();
                            }
                        } else {
                            tokenPrices[token] = null; // Explicitly set to null
                            logMessage(`❌ NO REAL-TIME PRICE for ${getTokenSymbol(token)}: ${data.data[index]}`, 'error');
                        }
                    });
                    
                    if (successCount === 0) {
                        logMessage(`❌ NO REAL-TIME PRICES AVAILABLE: All ${KNOWN_TOKENS.length} tokens failed to load`, 'error');
                        logMessage(`🚫 TRADING BLOCKED: Cannot trade without real-time price data`, 'error');
                    } else if (successCount < KNOWN_TOKENS.length) {
                        logMessage(`⚠️ PARTIAL PRICE DATA: Only ${successCount}/${KNOWN_TOKENS.length} tokens loaded`, 'warning');
                        logMessage(`🚫 TRADING LIMITED: Only tokens with real-time prices can be traded`, 'warning');
                    } else {
                        logMessage(`✅ Token prices loaded successfully: ${successCount}/${KNOWN_TOKENS.length} tokens`, 'success');
                    }
                    updateTokenDisplay();
                    updateBalanceDisplay(); // Update balances when prices change
                } else {
                    throw new Error(`Invalid response format: status=${data.status}, data=${JSON.stringify(data.data).substring(0, 100)}`);
                }
            } catch (error) {
                logMessage(`❌ Failed to load token prices: ${error.message}`, 'error');
                logMessage('🔄 Using fallback prices for demo purposes', 'info');
                
                // Fallback to demo prices if API fails
                KNOWN_TOKENS.forEach(token => {
                    if (!tokenPrices[token] || isNaN(tokenPrices[token])) {
                        const symbol = getTokenSymbol(token);
                        switch (symbol) {
                            case 'GALA': tokenPrices[token] = 0.0176; break;
                            case 'GUSDC': tokenPrices[token] = 1.0004; break;
                            case 'ETIME': tokenPrices[token] = 0.0052; break;
                            case 'FILM': tokenPrices[token] = 0.0095; break;
                            case 'GTON': tokenPrices[token] = 0.0175; break;
                            case 'GMUSIC': tokenPrices[token] = 1.0000; break;
                            case 'GOSMI': tokenPrices[token] = 0.0089; break;
                            default: tokenPrices[token] = 1.0; break;
                        }
                        logMessage(`📊 Set fallback price for ${symbol}: $${tokenPrices[token]}`, 'info');
                    }
                });
                
                updateTokenDisplay();
                updateBalanceDisplay();
            }
        }

        // Update the token display
        function updateTokenDisplay() {
            const tokenList = document.getElementById('tokenList');
            tokenList.innerHTML = '';

            // Get all opportunities including arbitrage
            const allOpportunities = [];
            
            // Add regular token opportunities
            Object.entries(tokenPrices).forEach(([token, price]) => {
                const opportunity = analyzeOpportunity(token, price);
                const arbitrage = detectArbitrageOpportunity(token, price);
                
                allOpportunities.push({
                    type: 'token',
                    token: token,
                    price: price,
                    opportunity: opportunity,
                    arbitrage: arbitrage
                });
            });
            
            // Add arbitrage opportunities between token pairs
            const arbitrageOpportunities = detectCrossTokenArbitrage();
            allOpportunities.push(...arbitrageOpportunities);
            
            // Add triangle arbitrage opportunities
            const triangleOpportunities = detectTriangleArbitrage();
            allOpportunities.push(...triangleOpportunities);

            // Sort by combined opportunity score (triangle arbitrage gets highest priority)
            allOpportunities.sort((a, b) => {
                let scoreA, scoreB;
                if (a.type === 'triangle') {
                    scoreA = a.triangle.profitPercent;
                } else if (a.type === 'arbitrage') {
                    scoreA = a.arbitrage.profitPercent;
                } else {
                    scoreA = a.opportunity.score;
                }
                
                if (b.type === 'triangle') {
                    scoreB = b.triangle.profitPercent;
                } else if (b.type === 'arbitrage') {
                    scoreB = b.arbitrage.profitPercent;
                } else {
                    scoreB = b.opportunity.score;
                }
                
                return scoreB - scoreA;
            });

            allOpportunities.forEach((item) => {
                const tokenItem = document.createElement('div');
                tokenItem.className = 'token-item';
                
                if (item.type === 'triangle') {
                    // Display triangle arbitrage opportunity
                    const profitClass = item.triangle.profitPercent > 0 ? 'positive' : 'negative';
                    const profitSymbol = item.triangle.profitPercent > 0 ? '+' : '';
                    
                    tokenItem.classList.add('opportunity');
                    tokenItem.innerHTML = `
                        <div class="token-name">🔺 ${item.triangle.symbolA} → ${item.triangle.symbolB} → ${item.triangle.symbolC} → ${item.triangle.symbolA}</div>
                        <div class="token-price">Triangle Arbitrage</div>
                        <div class="token-change ${profitClass}">${profitSymbol}${item.triangle.profitPercent.toFixed(2)}%</div>
                    `;
                } else if (item.type === 'arbitrage') {
                    // Display arbitrage opportunity
                    const profitClass = item.arbitrage.profitPercent > 0 ? 'positive' : 'negative';
                    const profitSymbol = item.arbitrage.profitPercent > 0 ? '+' : '';
                    
                    tokenItem.classList.add('opportunity');
                    tokenItem.innerHTML = `
                        <div class="token-name">🔄 ${item.arbitrage.fromSymbol} → ${item.arbitrage.toSymbol}</div>
                        <div class="token-price">$${item.arbitrage.fromPrice.toFixed(6)} → $${item.arbitrage.toPrice.toFixed(6)}</div>
                        <div class="token-change ${profitClass}">${profitSymbol}${item.arbitrage.profitPercent.toFixed(2)}%</div>
                    `;
                } else {
                    // Display regular token opportunity
                    const change = calculatePriceChange(item.token);
                const changeClass = change >= 0 ? 'positive' : 'negative';
                const changeSymbol = change >= 0 ? '+' : '';
                
                // Determine if this is an opportunity
                    if (item.opportunity.score > 0.7) {
                    tokenItem.classList.add('opportunity');
                    } else if (item.opportunity.score < 0.3) {
                    tokenItem.classList.add('risk');
                }
                    
                    // Add arbitrage indicator if available
                    const arbitrageIndicator = item.arbitrage.profitPercent > 1 ? ' 🔄' : '';
                
                tokenItem.innerHTML = `
                        <div class="token-name">${getTokenSymbol(item.token)}${arbitrageIndicator}</div>
                        <div class="token-price">$${item.price.toFixed(6)}</div>
                    <div class="token-change ${changeClass}">${changeSymbol}${change.toFixed(2)}%</div>
                `;
                }
                
                tokenList.appendChild(tokenItem);
            });
        }

        // Calculate price change percentage
        function calculatePriceChange(token) {
            const history = priceHistory[token];
            if (!history || history.length < 2) return 0;
            
            const current = history[history.length - 1].price;
            const previous = history[history.length - 2].price;
            
            return ((current - previous) / previous) * 100;
        }

        // Detect arbitrage opportunity for a single token (price vs historical average)
        function detectArbitrageOpportunity(token, currentPrice) {
            const history = priceHistory[token];
            if (!history || history.length < 5) {
                return { profitPercent: 0, isArbitrage: false };
            }
            
            // Calculate average price over last 10 periods
            const recentPrices = history.slice(-10).map(h => h.price);
            const avgPrice = recentPrices.reduce((sum, price) => sum + price, 0) / recentPrices.length;
            
            // Calculate profit percentage
            const profitPercent = ((currentPrice - avgPrice) / avgPrice) * 100;
            
            // SANITY CHECK: Reject unrealistic price movements
            if (Math.abs(profitPercent) > 20) { // More than 20% price change is suspicious
                return { profitPercent: 0, isArbitrage: false };
            }
            
            // Only consider it arbitrage if profit is significant (>1%) but realistic (<20%)
                    return { 
                profitPercent: profitPercent,
                isArbitrage: Math.abs(profitPercent) > 1 && Math.abs(profitPercent) < 20,
                avgPrice: avgPrice,
                currentPrice: currentPrice
            };
        }

        // Detect cross-token arbitrage opportunities
        function detectCrossTokenArbitrage() {
            const arbitrageOpportunities = [];
            
            // Only check trading pairs that actually exist and have liquidity
            const validPairs = [
                ['GALA|Unit|none|none', 'GUSDC|Unit|none|none'],
                ['GALA|Unit|none|none', 'GTON|Unit|none|none'],
                ['GUSDC|Unit|none|none', 'GTON|Unit|none|none']
            ];
            
            validPairs.forEach(([tokenA, tokenB]) => {
                const priceA = tokenPrices[tokenA];
                const priceB = tokenPrices[tokenB];
                
                if (!priceA || !priceB) return;
                
                // Calculate theoretical exchange rate
                const exchangeRate = priceA / priceB;
                
                // Check if there's a significant price difference
                const priceDiff = Math.abs(exchangeRate - 1) * 100;
                
                // SANITY CHECK: Reject unrealistic price differences
                if (priceDiff > 50) { // More than 50% difference is suspicious
                    return;
                }
                
                if (priceDiff > 2 && priceDiff < 50) { // Only show arbitrage if 2-50% difference
                    const fromToken = priceA > priceB ? tokenA : tokenB;
                    const toToken = priceA > priceB ? tokenB : tokenA;
                    const fromPrice = priceA > priceB ? priceA : priceB;
                    const toPrice = priceA > priceB ? priceB : priceA;
                    
                    arbitrageOpportunities.push({
                        type: 'arbitrage',
                        arbitrage: {
                            fromToken: fromToken,
                            toToken: toToken,
                            fromSymbol: getTokenSymbol(fromToken),
                            toSymbol: getTokenSymbol(toToken),
                            fromPrice: fromPrice,
                            toPrice: toPrice,
                            profitPercent: priceDiff,
                            exchangeRate: exchangeRate
                        }
                    });
                }
            });
            
            return arbitrageOpportunities;
        }

        // Detect triangle arbitrage opportunities (A -> B -> C -> A)
        function detectTriangleArbitrage() {
            const triangleOpportunities = [];
            const tokens = Object.keys(tokenPrices);
            
            // COMPETITION MODE: Check ALL available tokens for triangle arbitrage
            const availableTokens = tokens.filter(token => tokenPrices[token] > 0);
            
            if (availableTokens.length < 3) return triangleOpportunities;
            
            // Generate triangle arbitrage opportunities using USD price approximations
            // This is a simplified approach for competition - in reality you'd need actual exchange rates
            for (let i = 0; i < availableTokens.length; i++) {
                for (let j = 0; j < availableTokens.length; j++) {
                    for (let k = 0; k < availableTokens.length; k++) {
                        if (i === j || j === k || k === i) continue;
                        
                        const tokenA = availableTokens[i];
                        const tokenB = availableTokens[j];
                        const tokenC = availableTokens[k];
                        
                        const priceA = tokenPrices[tokenA];
                        const priceB = tokenPrices[tokenB];
                        const priceC = tokenPrices[tokenC];
                        
                        // Simplified triangle arbitrage calculation
                        // Start with 100 units of tokenA
                        const startAmount = 100;
                        const step1 = startAmount / priceA; // A -> B
                        const step2 = step1 / priceB; // B -> C  
                        const step3 = step2 * priceC; // C -> A
                        
                        const profit = step3 - startAmount;
                        const profitPercent = (profit / startAmount) * 100;
                        
                        // Only consider profitable opportunities (>1% profit)
                        if (profitPercent > 1) {
                            triangleOpportunities.push({
                                type: 'triangle',
                                triangle: {
                                    tokenA: tokenA,
                                    tokenB: tokenB,
                                    tokenC: tokenC,
                                    symbolA: getTokenSymbol(tokenA),
                                    symbolB: getTokenSymbol(tokenB),
                                    symbolC: getTokenSymbol(tokenC),
                                    path: `${getTokenSymbol(tokenA)} → ${getTokenSymbol(tokenB)} → ${getTokenSymbol(tokenC)} → ${getTokenSymbol(tokenA)}`,
                                    profitPercent: profitPercent,
                                    priceA: priceA,
                                    priceB: priceB,
                                    priceC: priceC,
                                    startAmount: startAmount,
                                    finalAmount: step3
                                }
                            });
                        }
                    }
                }
            }
            
            // Sort by profit percentage (highest first)
            return triangleOpportunities.sort((a, b) => b.triangle.profitPercent - a.triangle.profitPercent);
        }

        // Analyze trading opportunity with advanced strategies
        function analyzeOpportunity(token, currentPrice) {
            const history = priceHistory[token];
            if (!history || history.length < 2) {
                return { score: 0.5, reason: 'Insufficient data' };
            }
            
            // Use real analysis even with limited data (2+ points)
            if (history.length < 3) {
                // Simple momentum analysis with 2 data points
                const prevPrice = history[history.length - 1].price;
                const momentum = (currentPrice - prevPrice) / prevPrice;
                const score = momentum > 0.01 ? 0.7 : (momentum < -0.01 ? 0.3 : 0.5);
                
                return {
                    score: score,
                    confidence: 0.6,
                    reason: `Real momentum: ${(momentum * 100).toFixed(2)}%`,
                    momentum: momentum,
                    rsi: 50, // Neutral RSI with limited data
                    volatility: Math.abs(momentum)
                };
            }
            
            // Calculate moving averages
            const shortMA = calculateMovingAverage(history.slice(-5));
            const longMA = calculateMovingAverage(history.slice(-10));
            const veryShortMA = calculateMovingAverage(history.slice(-3));
            
            // Calculate volatility
            const volatility = calculateVolatility(history);
            
            // Calculate momentum
            const momentum = (currentPrice - longMA) / longMA;
            const shortMomentum = (currentPrice - veryShortMA) / veryShortMA;
            
            // Calculate RSI
            const rsi = calculateRSI(history);
            
            // Calculate MACD
            const macd = calculateMACD(history);
            
            // Calculate Bollinger Bands
            const bollinger = calculateBollingerBands(history);
            
            // Calculate volume-weighted average price (VWAP) approximation
            const vwap = calculateVWAP(history);
            
            // Advanced scoring system for competition
            let score = 0.5;
            let reasons = [];
            let confidence = 0;
            
            // 1. MOMENTUM STRATEGY (40% weight) - VERY aggressive for testing
            if (momentum > 0.01 && shortMomentum > 0.005) {
                score += 0.25;
                confidence += 0.3;
                reasons.push('Strong momentum trend');
            } else if (momentum > 0.005) {
                score += 0.15;
                confidence += 0.2;
                reasons.push('Positive momentum');
            } else if (momentum < -0.01) {
                score -= 0.25;
                confidence += 0.2;
                reasons.push('Strong downward momentum');
            } else if (momentum < -0.005) {
                score -= 0.15;
                confidence += 0.1;
                reasons.push('Negative momentum');
            }
            
            // 2. RSI OVERSOLD/OVERBOUGHT (25% weight) - VERY sensitive for testing
            if (rsi < 45) {
                score += 0.3;
                confidence += 0.4;
                reasons.push('Oversold (RSI < 45)');
            } else if (rsi < 50) {
                score += 0.2;
                confidence += 0.3;
                reasons.push('Near oversold (RSI < 50)');
            } else if (rsi > 55) {
                score -= 0.3;
                confidence += 0.4;
                reasons.push('Overbought (RSI > 55)');
            } else if (rsi > 50) {
                score -= 0.2;
                confidence += 0.3;
                reasons.push('Near overbought (RSI > 50)');
            }
            
            // 3. BOLLINGER BANDS STRATEGY (20% weight)
            if (currentPrice < bollinger.lower) {
                score += 0.25;
                confidence += 0.3;
                reasons.push('Price below lower Bollinger Band');
            } else if (currentPrice > bollinger.upper) {
                score -= 0.25;
                confidence += 0.3;
                reasons.push('Price above upper Bollinger Band');
            } else if (currentPrice > bollinger.middle && currentPrice < bollinger.upper) {
                score += 0.1;
                reasons.push('Price in upper Bollinger range');
            }
            
            // 4. MACD SIGNAL (10% weight)
            if (macd.histogram > 0 && macd.macd > macd.signal) {
                score += 0.15;
                confidence += 0.2;
                reasons.push('MACD bullish crossover');
            } else if (macd.histogram < 0 && macd.macd < macd.signal) {
                score -= 0.15;
                confidence += 0.2;
                reasons.push('MACD bearish crossover');
            }
            
            // 5. VOLATILITY ADJUSTMENT (5% weight)
            if (volatility > 0.03 && volatility < 0.15) {
                score += 0.1;
                reasons.push('Optimal volatility range');
            } else if (volatility > 0.25) {
                score -= 0.2;
                reasons.push('Extreme volatility risk');
            }
            
            // 6. VWAP STRATEGY
            if (currentPrice < vwap * 0.98) {
                score += 0.1;
                reasons.push('Price below VWAP (potential buy)');
            } else if (currentPrice > vwap * 1.02) {
                score -= 0.1;
                reasons.push('Price above VWAP (potential sell)');
            }
            
            // 7. COMPETITION-SPECIFIC SCORING - More aggressive thresholds
            // Look for tokens with high potential for quick gains
            const priceChange24h = calculate24hChange(history);
            if (priceChange24h > 0.05) {
                score += 0.15;
                reasons.push('Strong 24h performance');
            } else if (priceChange24h > 0.02) {
                score += 0.1;
                reasons.push('Positive 24h performance');
            } else if (priceChange24h < -0.05) {
                score -= 0.1;
                reasons.push('Weak 24h performance');
            }
            
            // 8. LIQUIDITY CONSIDERATION
            // Prefer tokens with more stable prices (better liquidity)
            if (volatility < 0.05 && history.length > 20) {
                score += 0.1;
                reasons.push('High liquidity token');
            }
            
            // Confidence adjustment
            const finalScore = Math.max(0, Math.min(1, score));
            const finalConfidence = Math.max(0, Math.min(1, confidence));
            
            return {
                score: finalScore,
                confidence: finalConfidence,
                reason: reasons.join(', ') || 'Neutral',
                momentum: momentum,
                rsi: rsi,
                volatility: volatility
            };
        }

        // Calculate moving average
        function calculateMovingAverage(prices) {
            const sum = prices.reduce((acc, item) => acc + item.price, 0);
            return sum / prices.length;
        }

        // Calculate volatility
        function calculateVolatility(history) {
            if (history.length < 2) return 0;
            
            const returns = [];
            for (let i = 1; i < history.length; i++) {
                const return_ = (history[i].price - history[i-1].price) / history[i-1].price;
                returns.push(return_);
            }
            
            const mean = returns.reduce((acc, ret) => acc + ret, 0) / returns.length;
            const variance = returns.reduce((acc, ret) => acc + Math.pow(ret - mean, 2), 0) / returns.length;
            
            return Math.sqrt(variance);
        }

        // Calculate RSI (Relative Strength Index)
        function calculateRSI(history) {
            if (history.length < 14) return 50;
            
            const gains = [];
            const losses = [];
            
            for (let i = 1; i < Math.min(15, history.length); i++) {
                const change = history[i].price - history[i-1].price;
                if (change > 0) {
                    gains.push(change);
                    losses.push(0);
                } else {
                    gains.push(0);
                    losses.push(Math.abs(change));
                }
            }
            
            const avgGain = gains.reduce((acc, gain) => acc + gain, 0) / gains.length;
            const avgLoss = losses.reduce((acc, loss) => acc + loss, 0) / losses.length;
            
            if (avgLoss === 0) return 100;
            
            const rs = avgGain / avgLoss;
            return 100 - (100 / (1 + rs));
        }

        // Calculate MACD (Moving Average Convergence Divergence)
        function calculateMACD(history) {
            if (history.length < 26) {
                return { macd: 0, signal: 0, histogram: 0 };
            }
            
            const prices = history.map(h => h.price);
            const ema12 = calculateEMA(prices, 12);
            const ema26 = calculateEMA(prices, 26);
            const macd = ema12 - ema26;
            
            // Calculate signal line (9-period EMA of MACD)
            const macdValues = [macd]; // Simplified - would need full MACD history
            const signal = calculateEMA(macdValues, 9);
            const histogram = macd - signal;
            
            return { macd, signal, histogram };
        }

        // Calculate EMA (Exponential Moving Average)
        function calculateEMA(prices, period) {
            if (prices.length < period) return prices[prices.length - 1];
            
            const multiplier = 2 / (period + 1);
            let ema = prices[0];
            
            for (let i = 1; i < prices.length; i++) {
                ema = (prices[i] * multiplier) + (ema * (1 - multiplier));
            }
            
            return ema;
        }

        // Calculate Bollinger Bands
        function calculateBollingerBands(history) {
            if (history.length < 20) {
                const price = history[history.length - 1].price;
                return { upper: price, middle: price, lower: price };
            }
            
            const prices = history.slice(-20).map(h => h.price);
            const sma = calculateMovingAverage(history.slice(-20));
            const variance = prices.reduce((acc, price) => acc + Math.pow(price - sma, 2), 0) / prices.length;
            const stdDev = Math.sqrt(variance);
            
            return {
                upper: sma + (2 * stdDev),
                middle: sma,
                lower: sma - (2 * stdDev)
            };
        }

        // Calculate VWAP (Volume Weighted Average Price) approximation
        function calculateVWAP(history) {
            if (history.length < 2) return history[0].price;
            
            let totalVolume = 0;
            let totalValue = 0;
            
            for (let i = 1; i < history.length; i++) {
                const price = (history[i].price + history[i-1].price) / 2;
                const volume = Math.abs(history[i].price - history[i-1].price) * 1000; // Approximate volume
                totalValue += price * volume;
                totalVolume += volume;
            }
            
            return totalVolume > 0 ? totalValue / totalVolume : history[history.length - 1].price;
        }

        // Calculate 24-hour price change
        function calculate24hChange(history) {
            if (history.length < 2) return 0;
            
            const current = history[history.length - 1].price;
            const previous = history[0].price;
            
            return (current - previous) / previous;
        }

        // Start the trading bot
        function startBot() {
            if (botRunning) return;
            
            if (!walletConnected) {
                logMessage('❌ Please connect your wallet first!', 'error');
                alert('Please connect your GalaChain wallet before starting the bot.');
                return;
            }
            
            // Warning for full trades
            if (!tradeCapMode) {
                const confirmLive = confirm('⚠️ FULL TRADES ENABLED ⚠️\n\nYou are about to start REAL trading with your GALA.\nThis will execute actual on-chain transactions.\n\nAre you sure you want to continue?');
                if (!confirmLive) {
                    logMessage('❌ Full trades cancelled by user', 'warning');
                    return;
                }
            }
            
            botRunning = true;
            botStartTime = Date.now();
            const botStatusElement = document.getElementById('botStatus');
            botStatusElement.textContent = 'Running';
            botStatusElement.style.color = '#4CAF50'; // Green for running
            const modeText = tradeCapMode ? 'TRADE CAP' : 'FULL TRADES';
            logMessage(`🏆 COMPETITION MODE ACTIVATED! 🏆`, 'success');
            logMessage(`🚀 Trading bot started in ${modeText} with REAL TRADING!`, 'success');
            logMessage(`✅ Using GalaChain SDK for real blockchain transactions`, 'success');
            logMessage(`⚡ SCANNING ALL PAIRS: GALA, GUSDC, ETIME, GTON, GOSMI, FILM, GMUSIC`, 'info');
            logMessage(`🔺 TRIANGLE ARBITRAGE: ENABLED`, 'info');
            logMessage(`🎯 OPPORTUNITY THRESHOLDS: LOWERED FOR MAXIMUM DETECTION`, 'info');
            
            // Start scanning for opportunities with mode-appropriate speed
            const activeConfig = getActiveConfig();
            scanInterval = setInterval(() => {
                scanForOpportunities();
                // Also process queued trades regularly
                processTradeQueue();
            }, activeConfig.scanInterval * 1000);
            
            const modeNames = {
                'conservative': 'CONSERVATIVE MODE',
                'tradecap': 'TRADE CAP MODE',
                'competition': 'COMPETITION MODE'
            };
            const speedTexts = {
                'conservative': 'SLOW & STEADY',
                'tradecap': 'MEDIUM SPEED',
                'competition': 'ULTRA-FAST'
            };
            
            logMessage(`⚡ ${speedTexts[tradingMode]} SCANNING: ${activeConfig.scanInterval}s intervals (${modeNames[tradingMode]})`, 'success');
            
            // Initial scan
            scanForOpportunities();
            
            // Process trade queue more frequently for better responsiveness
            setInterval(() => {
                processTradeQueue();
            }, 1000); // Check every second
        }

        // Stop the trading bot
        function stopBot() {
            if (!botRunning) return;
            
            botRunning = false;
            const botStatusElement = document.getElementById('botStatus');
            botStatusElement.textContent = 'Stopped';
            botStatusElement.style.color = '#f44336'; // Red for stopped
            logMessage('⏹️ Trading bot stopped', 'warning');
            
            if (scanInterval) {
                clearInterval(scanInterval);
                scanInterval = null;
            }
        }

        // Scan for trading opportunities (optimized for ultra-fast scanning)
        function scanForOpportunities() {
            if (!botRunning) return;
            
            // Reduce log spam for ultra-fast scanning
            if (Math.random() < 0.1) { // Only log 10% of scans to reduce spam
            logMessage('🔍 Scanning for opportunities...', 'info');
            }
            
            // Check if we have any liquid pairs available
            if (LIQUID_PAIRS.length === 0) {
                logMessage('⚠️ No liquid trading pairs available', 'warning');
                return;
            }
            
            // Update prices first (with caching for ultra-fast scanning)
            if (!window.lastPriceUpdate || Date.now() - window.lastPriceUpdate > 10000) { // Update prices every 10 seconds max
            loadTokenPrices();
                window.lastPriceUpdate = Date.now();
            }
            
            // Real trading analysis - no test mode
            logMessage('🔍 Scanning for real trading opportunities...', 'info');
            
            // Analyze each token for opportunities with detailed logging
            Object.entries(tokenPrices).forEach(([token, price]) => {
                // Check competition mode setting
                if (!competitionMode && !LIQUID_PAIRS.includes(token)) {
                    return; // Skip non-liquid pairs in standard mode
                }
                // COMPETITION MODE: Scan ALL tokens for maximum opportunities
                
                const opportunity = analyzeOpportunity(token, price);
                const arbitrage = detectArbitrageOpportunity(token, price);
                const symbol = getTokenSymbol(token);
                
                // Debug detailed analysis
                debugLog(`${symbol}: Score=${opportunity.score.toFixed(3)}, Confidence=${(opportunity.confidence || 0).toFixed(3)}, RSI=${opportunity.rsi?.toFixed(1) || 'N/A'}, Momentum=${(opportunity.momentum * 100)?.toFixed(2) || 'N/A'}%, Arbitrage=${arbitrage.profitPercent.toFixed(2)}%`, 'info');
                
                // Dynamic thresholds based on current trading mode
                const activeConfig = getActiveConfig();
                const arbitrageThreshold = activeConfig.arbitrageThreshold;
                const buyThreshold = activeConfig.buyThreshold;
                const sellThreshold = activeConfig.sellThreshold;
                
                // Check for arbitrage opportunities first
                if (arbitrage.isArbitrage && Math.abs(arbitrage.profitPercent) > arbitrageThreshold) {
                    logMessage(`🔄 ARBITRAGE: ${symbol} - ${arbitrage.profitPercent.toFixed(2)}% vs avg ($${arbitrage.avgPrice.toFixed(6)})`, 'success');
                    // Execute arbitrage trade
                    executeArbitrageTrade(token, price, arbitrage);
                } else if (opportunity.score > buyThreshold) {
                    logMessage(`🎯 BUY OPPORTUNITY: ${symbol} - ${opportunity.reason}`, 'success');
                    logMessage(`🚀 CALLING executeTrade for ${symbol} with score ${opportunity.score.toFixed(3)}`, 'info');
                    executeTrade(token, price, 'buy', opportunity);
                } else if (opportunity.score < sellThreshold) {
                    logMessage(`⚠️ SELL SIGNAL: ${symbol} - ${opportunity.reason}`, 'warning');
                    // Check if we have a position to sell
                    const existingPosition = window.activePositions?.find(pos => pos.token === token && pos.action === 'buy');
                    if (existingPosition) {
                        executeTrade(token, price, 'sell', opportunity);
                    }
                } else {
                    // Even if no specific opportunity, try a small trade in trade cap mode
                    if (tradeCapMode && Math.random() < 0.1 && token !== 'GALA|Unit|none|none') { // 10% chance of random trade, but not GALA for GALA
                        logMessage(`🎲 RANDOM TEST TRADE: ${symbol} - Testing bot functionality`, 'info');
                        executeTrade(token, price, 'buy', {
                            reason: 'Random test trade',
                            confidence: 0.5,
                            score: 0.5
                        });
                    }
                }
                
                // Also try to sell any tokens we have for GALA (but not GALA itself)
                const availableTokens = tokenBalances[token] || 0;
                if (availableTokens > 0.01 && Math.random() < 0.05 && token !== 'GALA|Unit|none|none') { // 5% chance to sell tokens, but not GALA
                    logMessage(`💰 SELL OPPORTUNITY: ${symbol} - Converting to GALA`, 'info');
                    executeTrade(token, price, 'sell', {
                        reason: 'Convert to GALA',
                        confidence: 0.6,
                        score: 0.6
                    });
                }
            });
            
            // Check for cross-token arbitrage opportunities
            const crossArbitrage = detectCrossTokenArbitrage();
            crossArbitrage.forEach(arb => {
                const crossArbitrageThreshold = competitionMode ? 1.5 : 3;
                if (arb.arbitrage.profitPercent > crossArbitrageThreshold) {
                    // Check if we have the source token
                    const availableBalance = tokenBalances[arb.arbitrage.fromToken] || 0;
                    if (availableBalance > 0.01) { // Only if we have at least 0.01 of the source token
                        logMessage(`🔄 CROSS-ARBITRAGE: ${arb.arbitrage.fromSymbol} → ${arb.arbitrage.toSymbol} (${arb.arbitrage.profitPercent.toFixed(2)}%)`, 'success');
                        executeCrossArbitrageTrade(arb.arbitrage);
                    } else {
                        logMessage(`⚠️ Skipping cross-arbitrage ${arb.arbitrage.fromSymbol} → ${arb.arbitrage.toSymbol} - No ${arb.arbitrage.fromSymbol} balance`, 'warning');
                    }
                }
            });
            
            // GALA-based trading - dynamic based on competition mode
            if (galaBalance > 1) { // Only if we have at least 1 GALA
                const tokensToTest = competitionMode ? 
                    Object.keys(tokenPrices).filter(token => token !== 'GALA|Unit|none|none' && tokenPrices[token] > 0) : // All tokens except GALA in competition mode
                    ['GUSDC|Unit|none|none', 'GTON|Unit|none|none']; // Limited tokens in standard mode
                
                tokensToTest.forEach(token => {
                    const price = tokenPrices[token];
                    if (price && Math.random() < (competitionMode ? 0.1 : 0.15)) { // 10% in competition, 15% in standard
                        const symbol = getTokenSymbol(token);
                        logMessage(`🎯 GALA TRADE: ${symbol} - Testing GALA-based trading`, 'info');
                        executeTrade(token, price, 'buy', {
                            reason: 'GALA-based trading',
                            confidence: 0.7,
                            score: 0.7
                        });
                    }
                });
            }
            
            // Check for triangle arbitrage opportunities (only in competition mode)
            const triangleArbitrage = competitionMode ? detectTriangleArbitrage() : [];
            
            // Filter and prioritize achievable opportunities
            const achievableTriangles = triangleArbitrage
                .filter(tri => {
                    const profit = tri.triangle.profitPercent;
                    const startToken = tri.triangle.tokenA;
                    const startBalance = tokenBalances[startToken] || 0;
                    
                    // Only consider realistic profits (2-50%) and if we have some balance OR if profit is reasonable (>5%)
                    return profit > 2 && profit < 50 && (startBalance > 1 || profit > 5);
                })
                .sort((a, b) => {
                    // Prioritize opportunities we can execute immediately
                    const aHasBalance = (tokenBalances[a.triangle.tokenA] || 0) > 1;
                    const bHasBalance = (tokenBalances[b.triangle.tokenA] || 0) > 1;
                    
                    if (aHasBalance && !bHasBalance) return -1;
                    if (!aHasBalance && bHasBalance) return 1;
                    
                    // If both have same balance status, sort by profit
                    return b.triangle.profitPercent - a.triangle.profitPercent;
                })
                .slice(0, 1); // Only take the best achievable opportunity
            
            achievableTriangles.forEach(tri => {
                logMessage(`🔺 TRIANGLE ARBITRAGE: ${tri.triangle.path} (${tri.triangle.profitPercent.toFixed(2)}%)`, 'success');
                executeTriangleArbitrageTrade(tri.triangle);
            });
        }

        // Execute arbitrage trade (buy low, sell high)
        async function executeArbitrageTrade(token, currentPrice, arbitrage) {
            if (!walletConnected) {
                logMessage('❌ Wallet not connected. Please connect your wallet first.', 'error');
                return;
            }
            
            const symbol = getTokenSymbol(token);
            const isOverpriced = arbitrage.profitPercent > 0;
            
            if (isOverpriced) {
                // Token is overpriced - sell it
                logMessage(`🔄 ARBITRAGE SELL: ${symbol} at $${currentPrice.toFixed(6)} (${arbitrage.profitPercent.toFixed(2)}% above avg)`, 'success');
                // Check if we have this token to sell
                const balance = tokenBalances[token] || 0;
                if (balance > 0) {
                    const sellAmount = Math.min(balance * 0.5, balance); // Sell up to 50% of holdings
                    executeTrade(token, currentPrice, 'sell', {
                        reason: `Arbitrage: ${arbitrage.profitPercent.toFixed(2)}% above average`,
                        confidence: 0.8,
                        score: 0.8
                    });
                }
            } else {
                // Token is underpriced - buy it
                logMessage(`🔄 ARBITRAGE BUY: ${symbol} at $${currentPrice.toFixed(6)} (${Math.abs(arbitrage.profitPercent).toFixed(2)}% below avg)`, 'success');
                executeTrade(token, currentPrice, 'buy', {
                    reason: `Arbitrage: ${Math.abs(arbitrage.profitPercent).toFixed(2)}% below average`,
                    confidence: 0.8,
                    score: 0.8
                });
            }
        }

        // Execute cross-token arbitrage trade
        async function executeCrossArbitrageTrade(arbitrage) {
            if (!walletConnected) {
                logMessage('❌ Wallet not connected. Please connect your wallet first.', 'error');
                return;
            }
            
            const fromToken = arbitrage.fromToken;
            const toToken = arbitrage.toToken;
            const fromSymbol = arbitrage.fromSymbol;
            const toSymbol = arbitrage.toSymbol;
            
            // Check if we have enough of the source token (including 1 GALA fee)
            const availableBalance = tokenBalances[fromToken] || 0;
            const minRequired = tradeCapMode ? 1.01 : 1.01; // Need at least 1.01 GALA for fee + trade
            if (availableBalance < minRequired) {
                logMessage(`❌ Insufficient balance: ${availableBalance.toFixed(4)} < ${minRequired} required for ${fromSymbol} → ${toSymbol} (includes 1 GALA fee)`, 'warning');
                return;
            }
            
            // Calculate trade amount based on available balance and test mode
            const maxTradeAmount = Math.min(availableBalance * 0.1, tradeCapMode ? 25 : 100); // Use max 10% of balance, account for 1 GALA fee
            const tradeAmount = tradeCapMode ? Math.min(Math.random() * 20 + 5, maxTradeAmount) : maxTradeAmount; // 5-25 GALA range
            
            if (tradeAmount < 1.01) { // Minimum 1.01 GALA to cover 1 GALA fee + 0.01 trade
                logMessage(`❌ Trade amount too small: ${tradeAmount.toFixed(4)} ${fromSymbol} (need at least 1.01 GALA for fee)`, 'warning');
                return;
            }
            
            logMessage(`🔄 CROSS-ARBITRAGE: ${fromSymbol} → ${toSymbol} (${arbitrage.profitPercent.toFixed(2)}% profit)`, 'success');
            logMessage(`💰 Executing cross-arbitrage: ${tradeAmount.toFixed(4)} ${fromSymbol} → ${toSymbol}`, 'info');
            
            try {
                // Get quote for the swap
                const quote = await getSwapQuote(fromToken, toToken, tradeAmount);
                if (!quote) {
                    logMessage(`❌ No liquidity for ${fromSymbol} → ${toSymbol}`, 'warning');
                    return;
                }
                
                // Execute the swap
                const swapResult = await executeSwap(fromToken, toToken, tradeAmount, quote);
                
                if (swapResult.success) {
                    // Update balances
                    tokenBalances[fromToken] = (tokenBalances[fromToken] || 0) - tradeAmount;
                    tokenBalances[toToken] = (tokenBalances[toToken] || 0) + (Number(quote.amountOut) || 0);
                    
                    const profit = (Number(quote.amountOut) || 0) - tradeAmount;
                    const simulationNote = swapResult.data?.isSimulation ? ' (SIMULATED)' : '';
                    logMessage(`✅ Cross-arbitrage completed! Profit: ${profit.toFixed(4)} ${toSymbol}${simulationNote}`, 'success');
                    
                    // Update portfolio
                    portfolioValue = calculatePortfolioValue();
                    updateStatus();
                    updateBalanceDisplay();
                } else {
                    logMessage(`❌ Cross-arbitrage failed: ${swapResult.error}`, 'error');
                }
            } catch (error) {
                logMessage(`❌ Cross-arbitrage error: ${error.message}`, 'error');
            }
        }

        // Execute triangle arbitrage trade (A -> B -> C -> A)
        async function executeTriangleArbitrageTrade(triangle) {
            if (!walletConnected) {
                logMessage('❌ Wallet not connected. Please connect your wallet first.', 'error');
                return;
            }
            
            // Check if profit is realistic before proceeding
            if (triangle.profitPercent > 50) {
                logMessage(`⚠️ Skipping unrealistic triangle arbitrage: ${triangle.path} (${triangle.profitPercent.toFixed(2)}% profit)`, 'warning');
                return;
            }
            
            logMessage(`🔺 TRIANGLE ARBITRAGE: ${triangle.path} (${triangle.profitPercent.toFixed(2)}% profit)`, 'success');
            
            // Calculate optimal trade size based on available balance and test mode
            const startBalance = tokenBalances[triangle.tokenA] || 0;
            let tradeAmount;
            
            if (tradeCapMode) {
                // Test mode: Use small amounts for better test results
                tradeAmount = Math.min(startBalance * 0.05, 5); // Max 5% of balance or 5 tokens
                logMessage(`🔒 TRADE CAP: Using triangle arbitrage amount of ${tradeAmount.toFixed(4)} ${triangle.symbolA}`, 'info');
            } else {
                // Live mode: Use normal amounts
                tradeAmount = Math.min(startBalance * 0.1, 100); // Max 10% of balance or 100 tokens
            }
            
            // If we don't have enough of the starting token, try to acquire it
            if (tradeAmount < 1) {
                logMessage(`⚠️ Insufficient balance for triangle arbitrage: ${triangle.symbolA}`, 'warning');
                
                // Check if we can acquire the token through GALA swap
                const galaBalance = tokenBalances['GALA|Unit|none|none'] || 0;
                if (galaBalance > 10) { // Need at least 10 GALA to make it worthwhile
                    const acquisitionResult = await acquireTokenForArbitrage(triangle.tokenA, triangle);
                    if (acquisitionResult.success) {
                        tradeAmount = acquisitionResult.amount;
                        logMessage(`✅ Acquired ${tradeAmount.toFixed(4)} ${triangle.symbolA} for arbitrage`, 'success');
                    } else {
                        logMessage(`❌ Failed to acquire ${triangle.symbolA} for arbitrage`, 'error');
                        return;
                    }
                } else {
                    logMessage(`❌ Insufficient GALA balance to acquire ${triangle.symbolA}`, 'error');
                    return;
                }
            }
            
            logMessage(`💰 CALCULATING triangle arbitrage with ${tradeAmount.toFixed(4)} ${triangle.symbolA}`, 'info');
            
            // Step 1: A -> B
            logMessage(`Step 1: ${tradeAmount.toFixed(4)} ${triangle.symbolA} → ${triangle.symbolB}`, 'info');
            
            // Step 2: B -> C  
            const step1Amount = tradeAmount / triangle.priceA;
            logMessage(`Step 2: ${step1Amount.toFixed(4)} ${triangle.symbolB} → ${triangle.symbolC}`, 'info');
            
            // Step 3: C -> A
            const step2Amount = step1Amount / triangle.priceB;
            const finalAmount = step2Amount * triangle.priceC;
            logMessage(`Step 3: ${step2Amount.toFixed(4)} ${triangle.symbolC} → ${finalAmount.toFixed(4)} ${triangle.symbolA}`, 'info');
            
            const profit = finalAmount - tradeAmount;
            const profitPercent = (profit / tradeAmount) * 100;
            
            // Only show realistic profits (less than 10%)
            if (profitPercent < 10) {
                logMessage(`✅ Triangle arbitrage CALCULATED: ${profit.toFixed(4)} ${triangle.symbolA} profit (${profitPercent.toFixed(2)}%)`, 'success');
                logMessage(`⚠️ Note: This is a calculation only - no real trades executed due to API limitations`, 'warning');
            } else {
                logMessage(`⚠️ Triangle arbitrage calculation shows unrealistic profit (${profitPercent.toFixed(2)}%) - likely due to price data limitations`, 'warning');
                logMessage(`🔍 Price data may be inaccurate for: ${triangle.symbolA} ($${triangle.priceA}), ${triangle.symbolB} ($${triangle.priceB}), ${triangle.symbolC} ($${triangle.priceC})`, 'info');
            }
            
            // Note: Balance updates disabled for triangle arbitrage calculations
            // These are theoretical calculations only, not real trades
            // if (tokenBalances[triangle.tokenA]) {
            //     tokenBalances[triangle.tokenA] += profit;
            // }
            
            // Update portfolio value
            portfolioValue = calculatePortfolioValue();
            updateStatus();
            updateBalanceDisplay();
        }

        // Acquire token needed for triangle arbitrage with fallback strategies
        async function acquireTokenForArbitrage(targetToken, triangle) {
            const galaBalance = tokenBalances['GALA|Unit|none|none'] || 0;
            const targetSymbol = getTokenSymbol(targetToken);
            
            // Calculate how much GALA we need to spend to get enough target token
            const targetPrice = tokenPrices[targetToken] || 0;
            if (!targetPrice) {
                return { success: false, error: 'Target token price not available' };
            }
            
            // Calculate required amount for profitable arbitrage
            const requiredAmount = tradeCapMode ? 5 : 50; // Small amount in trade cap mode, normal in full trades mode
            const galaNeeded = requiredAmount * targetPrice;
            
            // Check if we have enough GALA and if the arbitrage is still profitable after acquisition cost
            if (galaNeeded > galaBalance * 0.2) { // Don't spend more than 20% of GALA balance
                return { success: false, error: 'Not enough GALA for acquisition' };
            }
            
            // Calculate net profit after acquisition cost
            const acquisitionCost = galaNeeded;
            const arbitrageProfit = (requiredAmount * triangle.profitPercent / 100) * targetPrice;
            const netProfit = arbitrageProfit - acquisitionCost;
            
            if (netProfit <= 0) {
                return { success: false, error: 'Arbitrage not profitable after acquisition cost' };
            }
            
            logMessage(`💡 Evaluating token acquisition: Need ${galaNeeded.toFixed(4)} GALA → ${requiredAmount.toFixed(4)} ${targetSymbol}`, 'info');
            logMessage(`💰 Expected net profit after acquisition: ${netProfit.toFixed(4)} GALA (${(netProfit/galaNeeded*100).toFixed(2)}%)`, 'info');
            
            // Try direct acquisition first (GALA -> target token)
            try {
                const quote = await getSwapQuote('GALA|Unit|none|none', targetToken, galaNeeded);
                if (quote) {
                    const swapResult = await executeSwap('GALA|Unit|none|none', targetToken, galaNeeded, quote);
                    
                    if (swapResult.success) {
                        // Update balances
                        tokenBalances['GALA|Unit|none|none'] -= galaNeeded;
                        tokenBalances[targetToken] = (tokenBalances[targetToken] || 0) + (Number(quote.amountOut) || 0);
                        
                        logMessage(`✅ Direct token acquisition successful: ${galaNeeded.toFixed(4)} GALA → ${(Number(quote.amountOut) || 0).toFixed(4)} ${targetSymbol}`, 'success');
                        
                        return {
                            success: true,
                            amount: Number(quote.amountOut) || 0,
                            galaSpent: galaNeeded,
                            netProfit: netProfit
                        };
                    }
                }
            } catch (error) {
                logMessage(`⚠️ Direct acquisition failed: ${error.message}`, 'warning');
            }
            
            // Try alternative acquisition routes if direct fails
            logMessage(`🔄 Trying alternative acquisition routes for ${targetSymbol}...`, 'info');
            
            // Try GALA -> GUSDC -> target token (if GUSDC has liquidity)
            const alternativeRoutes = [
                { intermediate: 'GUSDC|Unit|none|none', symbol: 'GUSDC' },
                { intermediate: 'GTON|Unit|none|none', symbol: 'GTON' },
            ];
            
            for (const route of alternativeRoutes) {
                try {
                    // Check if we can get the intermediate token first
                    const intermediateQuote = await getSwapQuote('GALA|Unit|none|none', route.intermediate, galaNeeded);
                    if (intermediateQuote) {
                        // Try to get target token from intermediate
                        const targetQuote = await getSwapQuote(route.intermediate, targetToken, intermediateQuote.amountOut);
                        if (targetQuote) {
                            logMessage(`✅ Found alternative route: GALA → ${route.symbol} → ${targetSymbol}`, 'success');
                            
                            // Execute the two-step acquisition
                            const step1Result = await executeSwap('GALA|Unit|none|none', route.intermediate, galaNeeded, intermediateQuote);
                            if (step1Result.success) {
                                const step2Result = await executeSwap(route.intermediate, targetToken, intermediateQuote.amountOut, targetQuote);
                                if (step2Result.success) {
                                    // Update balances
                                    tokenBalances['GALA|Unit|none|none'] -= galaNeeded;
                                    tokenBalances[targetToken] = (tokenBalances[targetToken] || 0) + (targetQuote.amountOut || 0);
                                    
                                    logMessage(`✅ Alternative acquisition successful: GALA → ${route.symbol} → ${(targetQuote.amountOut || 0).toFixed(4)} ${targetSymbol}`, 'success');
                                    
                                    return {
                                        success: true,
                                        amount: targetQuote.amountOut || 0,
                                        galaSpent: galaNeeded,
                                        netProfit: netProfit
                                    };
                                }
                            }
                        }
                    }
                } catch (error) {
                    // Continue to next route
                    continue;
                }
            }
            
            return { success: false, error: 'No viable acquisition route found' };
        }

        // Trade execution with rate limiting (3-MODE SYSTEM)
        function canExecuteTrade() {
            const now = Date.now();
            const currentSecondFloor = Math.floor(now / 1000);
            
            // Reset counter for new second
            if (currentSecondFloor !== currentSecond) {
                tradesThisSecond = 0;
                currentSecond = currentSecondFloor;
            }
            
            // Use active configuration based on current mode
            const activeConfig = getActiveConfig();
            
            // Check rate limits
            if (tradesThisSecond >= activeConfig.maxTradesPerSecond) {
                return false; // Rate limit exceeded
            }
            
            if (executingTrades >= activeConfig.concurrentTrades) {
                return false; // Too many concurrent trades
            }
            
            return true;
        }

        // Execute a trade with real GalaSwap API integration
        async function executeTrade(token, price, action, opportunity) {
            const symbol = getTokenSymbol(token);
            
            // SAFETY CHECK: Ensure we have real-time price data
            if (!price || price === null || isNaN(price) || price <= 0) {
                logMessage(`❌ TRADING BLOCKED: No real-time price data for ${symbol} (price: ${price})`, 'error');
                return;
            }
            
            // SAFETY CHECK: Ensure token price is from real-time data
            if (!tokenPrices[token] || tokenPrices[token] === null || isNaN(tokenPrices[token])) {
                logMessage(`❌ TRADING BLOCKED: No real-time price data for ${symbol} in tokenPrices`, 'error');
                return;
            }
            
            logMessage(`🔧 executeTrade called: ${action} ${symbol} at $${price.toFixed(6)}`, 'info');
            
            if (!walletConnected) {
                logMessage('❌ Wallet not connected. Please connect your wallet first.', 'error');
                return;
            }
            
            // Check trading limits based on current mode
            if (!canExecuteTrade()) {
                const activeConfig = getActiveConfig();
                const modeNames = {
                    'conservative': 'CONSERVATIVE',
                    'tradecap': 'TRADE CAP',
                    'competition': 'COMPETITION'
                };
                const modeText = modeNames[tradingMode];
                logMessage(`⏳ Trade queued: ${symbol} (${modeText} mode: ${tradesThisSecond}/${activeConfig.maxTradesPerSecond} trades/sec, ${executingTrades}/${activeConfig.concurrentTrades} concurrent)`, 'info');
                tradeQueue.push({ token, price, action, opportunity });
                return;
            }
            
            // Increment counters
            tradesThisSecond++;
            executingTrades++;
            lastTradeTime = Date.now();
            
            // Prevent GALA → GALA trades
            if (token === 'GALA|Unit|none|none' && action === 'buy') {
                logMessage(`⚠️ Skipping GALA → GALA trade (self-trading not allowed)`, 'warning');
                return;
            }
            
            // Calculate confidence multiplier (used in both trade cap and full trades mode)
            const confidenceMultiplier = Math.min(opportunity.confidence || 0.5, 1.0);
            
            // Calculate position size based on trade cap mode
            let positionSize, adjustedAmount;
            
            if (tradeCapMode) {
                // Trade cap mode: Use small fixed amounts for better test results
                // Account for 1 GALA transaction fee, so use 5-25 GALA range
                const maxAvailable = Math.min(galaBalance - 1, 25); // Leave 1 GALA for fees, max 25 GALA
                const testAmount = Math.min(Math.random() * 20 + 5, maxAvailable); // Random between 5-25 GALA, but not more than available
                
                if (testAmount < 5) {
                    logMessage(`⚠️ Insufficient GALA balance for trade: ${galaBalance.toFixed(4)} GALA (need at least 6 GALA for 5 GALA trade + 1 GALA fee)`, 'warning');
                    return;
                }
                
                positionSize = testAmount; // This is the GALA amount we want to spend
                adjustedAmount = testAmount; // This should be the GALA amount, not token amount
                logMessage(`🔒 TRADE CAP: Using position size of ${testAmount.toFixed(4)} GALA (includes 1 GALA fee)`, 'info');
                logMessage(`🔍 Position calculated: ${(testAmount / price).toFixed(4)} ${symbol} for ${testAmount.toFixed(4)} GALA`, 'info');
            } else {
                // Live mode: Use full position sizing
                const activeConfig = getActiveConfig();
                positionSize = (portfolioValue * activeConfig.maxPositionSize / 100);
            const amount = positionSize / price;
            
            // Calculate confidence-based position sizing
            const adjustedPositionSize = positionSize * confidenceMultiplier;
                adjustedAmount = adjustedPositionSize; // This should be the GALA amount, not token amount
            }
            
            // Dynamic liquidity handling based on competition mode
            if (competitionMode) {
                logMessage(`🔍 COMPETITION MODE: Attempting trade for ${symbol} (action=${action})`, 'info');
            } else {
                // Standard mode: Check for high-liquidity tokens
                const highLiquidityTokens = ['GUSDC|Unit|none|none', 'GTON|Unit|none|none'];
                const isHighLiquidity = highLiquidityTokens.includes(token);
                
                logMessage(`🔍 Liquidity check: ${symbol} isHighLiquidity=${isHighLiquidity}, action=${action}`, 'info');
                
                if (!isHighLiquidity && action === 'buy') {
                    logMessage(`⚠️ Skipping ${symbol} - Low liquidity token, focusing on high-volume pairs`, 'warning');
                    return;
                }
            }
            
            logMessage(`🔍 After liquidity check: proceeding with trade for ${symbol}`, 'info');
            logMessage(`🔍 Confidence multiplier: ${confidenceMultiplier.toFixed(3)} for ${symbol}`, 'info');
            logMessage(`💰 ${action.toUpperCase()}: ${(adjustedAmount / price).toFixed(4)} ${symbol} at $${price.toFixed(6)} (Confidence: ${Math.round(confidenceMultiplier * 100)}%)`, 'success');
            
            try {
                if (action === 'buy') {
                    // Get quote from GalaSwap (GALA -> other token)
                    logMessage(`🔍 Getting quote for GALA → ${symbol} (${adjustedAmount.toFixed(4)} GALA)`, 'info');
                    const quote = await getSwapQuote('GALA|Unit|none|none', token, adjustedAmount);
                    if (!quote) {
                        logMessage(`⚠️ No liquidity for GALA → ${symbol}, trying next opportunity`, 'warning');
                        return;
                    }
                    
                    logMessage(`✅ Quote received: ${(Number(quote.amountOut) || 0).toFixed(4)} ${symbol} for ${adjustedAmount.toFixed(4)} GALA`, 'success');
                    
                    // Execute swap (GALA -> other token)
                    logMessage(`🚀 Executing swap: GALA → ${symbol}`, 'info');
                    const swapResult = await executeSwap('GALA|Unit|none|none', token, adjustedAmount, quote);
                    
                    // Log swap attempt
                    totalSwaps++;
                    const swapData = {
                        direction: 'BUY',
                        tokenIn: 'GALA',
                        tokenOut: symbol,
                        amountIn: adjustedAmount,
                        amountOut: Number(quote.amountOut) || 0,
                        txHash: swapResult.txHash || 'N/A',
                        error: swapResult.error || null
                    };
                    
                    if (swapResult.success) {
                        successfulSwaps++;
                        activeTrades++;
                        
                        // Update token balances
                        tokenBalances['GALA|Unit|none|none'] -= adjustedAmount;
                        tokenBalances[token] = (tokenBalances[token] || 0) + (Number(quote.amountOut) || adjustedAmount);
                        
                        // Store trade for profit tracking
                        const trade = {
                            token: token,
                            symbol: symbol,
                            action: action,
                            amount: adjustedAmount,
                            price: price,
                            timestamp: Date.now(),
                            confidence: opportunity.confidence,
                            reason: opportunity.reason,
                            transactionHash: swapResult.txHash
                        };
                        
                        if (!window.activePositions) window.activePositions = [];
                        window.activePositions.push(trade);
                        
                        // Update portfolio value
                        portfolioValue -= adjustedAmount;
                        
                        // Update displays
                        updateBalanceDisplay();
                        updateStatus();
                        updateSwapStats();
                        
                        // Log successful swap
                        logSwap(swapData, 'success');
                        const simulationNote = swapResult.data?.isSimulated ? ' (SIMULATED - DEMO MODE)' : ' (REAL ON-CHAIN)';
                        logMessage(`✅ Trade executed: Bought ${adjustedAmount.toFixed(4)} ${symbol} (${opportunity.reason}) | TX: ${swapResult.txHash}${simulationNote}`, 'success');
                        
                        // Set up profit/loss monitoring for this trade
                        setTimeout(() => {
                            monitorTrade(trade);
                        }, 5000);
                        
                    } else {
                        failedSwaps++;
                        logSwap(swapData, 'error');
                        if (swapResult.isSimulation) {
                            logMessage(`⚠️ SIMULATION: ${adjustedAmount.toFixed(4)} GALA → ${symbol} (No real transaction)`, 'warning');
                        } else {
                            logMessage(`❌ Trade failed: ${swapResult.error}`, 'error');
                        }
                    }
                    
                } else if (action === 'sell') {
                    // Find matching buy trade
                    const buyTrade = window.activePositions.find(pos => pos.token === token && pos.action === 'buy');
                    if (buyTrade) {
                        // Get quote for selling (other token -> GALA)
                        const quote = await getSwapQuote(token, 'GALA|Unit|none|none', buyTrade.amount);
                        if (!quote) {
                            logMessage(`❌ Failed to get sell quote for ${symbol}`, 'error');
                            return;
                        }
                        
                        // Execute sell swap (other token -> GALA)
                        const swapResult = await executeSwap(token, 'GALA|Unit|none|none', buyTrade.amount, quote);
                        
                        // Log swap attempt
                        totalSwaps++;
                        const swapData = {
                            direction: 'SELL',
                            tokenIn: symbol,
                            tokenOut: 'GALA',
                            amountIn: buyTrade.amount,
                            amountOut: Number(quote.amountOut) || 0,
                            txHash: swapResult.txHash || 'N/A',
                            error: swapResult.error || null
                        };
                        
                        if (swapResult.success) {
                            successfulSwaps++;
                            
                            // Update token balances
                            tokenBalances[token] -= buyTrade.amount;
                            tokenBalances['GALA|Unit|none|none'] += (Number(quote.amountOut) || buyTrade.amount);
                            
                            const profit = (price - buyTrade.price) * buyTrade.amount;
                            totalProfit += profit;
                            portfolioValue += (buyTrade.amount * price);
                            activeTrades--;
                            totalTrades++;
                            
                            const profitPercent = ((price - buyTrade.price) / buyTrade.price) * 100;
                            const profitClass = profit > 0 ? 'success' : 'error';
                            
                            // Track winning trades
                            if (profit > 0) {
                                winningTrades++;
                                tradingStats.successfulTrades++;
                                tradingStats.bestTrade = Math.max(tradingStats.bestTrade, profit);
                            } else {
                                tradingStats.failedTrades++;
                                tradingStats.worstTrade = Math.min(tradingStats.worstTrade, profit);
                            }
                            
                            // Update trading statistics
                            tradingStats.totalVolume += buyTrade.amount;
                            
                            // Save updated statistics and portfolio data
                            saveTradingStats();
                            savePortfolioData();
                            
                            // Record trade history
                            const tradeRecord = {
                                symbol: symbol,
                                buyPrice: buyTrade.price,
                                sellPrice: price,
                                amount: buyTrade.amount,
                                profit: profit,
                                profitPercent: profitPercent,
                                duration: Date.now() - buyTrade.timestamp,
                                reason: opportunity.reason,
                                timestamp: Date.now(),
                                sellTxHash: swapResult.txHash
                            };
                            tradeHistory.push(tradeRecord);
                            
                            // Update displays
                            updateBalanceDisplay();
                            updateStatus();
                            updateSwapStats();
                            
                            // Log successful swap
                            logSwap(swapData, 'success');
                            logMessage(`💰 SELL: ${buyTrade.amount.toFixed(4)} ${symbol} at $${price.toFixed(6)} | Profit: $${profit.toFixed(2)} (${profitPercent.toFixed(2)}%) | TX: ${swapResult.txHash}`, profitClass);
                            
                            // Remove from active positions
                            window.activePositions = window.activePositions.filter(pos => pos !== buyTrade);
                        } else {
                            failedSwaps++;
                            logSwap(swapData, 'error');
                            if (swapResult.isSimulation) {
                                logMessage(`⚠️ SIMULATION: ${buyTrade.amount.toFixed(4)} ${symbol} → GALA (No real transaction)`, 'warning');
                            } else {
                                logMessage(`❌ Sell failed: ${swapResult.error}`, 'error');
                            }
                        }
                    }
                }
                
            } catch (error) {
                logMessage(`❌ Trade execution error: ${error.message}`, 'error');
            } finally {
                // Decrement concurrent trade counter
                executingTrades--;
                
                // Process queued trades
                processTradeQueue();
            }
            
            updateStatus();
        }
        
        // Process queued trades when capacity is available
        function processTradeQueue() {
            if (tradeQueue.length > 0 && canExecuteTrade()) {
                const queuedTrade = tradeQueue.shift();
                logMessage(`🔄 Processing queued trade: ${getTokenSymbol(queuedTrade.token)}`, 'info');
                executeTrade(queuedTrade.token, queuedTrade.price, queuedTrade.action, queuedTrade.opportunity);
            }
        }

        // Get swap quote from GalaSwap API
        async function getSwapQuote(tokenIn, tokenOut, amountIn) {
            try {
                // Check if we have enough balance (only for GALA trades)
                if (tokenIn === 'GALA|Unit|none|none') {
                const currentBalance = tokenBalances[tokenIn] || 0;
                if (currentBalance < amountIn) {
                    logMessage(`Insufficient balance: ${currentBalance.toFixed(4)} < ${amountIn.toFixed(4)}`, 'error');
                    return null;
                    }
                }
                
                // Use real SDK if available
                if (gswapSDK && gswapSDK.signer) {
                    try {
                        logMessage(`🔍 Getting REAL SDK quote: ${amountIn} ${getTokenSymbol(tokenIn)} → ${getTokenSymbol(tokenOut)}`, 'info');
                        
                        const quote = await gswapSDK.quoting.quoteExactInput(tokenIn, tokenOut, amountIn.toString(), 500);
                        
                        logMessage(`✅ Real SDK quote received: ${quote.amountOut || quote.outTokenAmount} ${getTokenSymbol(tokenOut)}`, 'success');
                        
                        return {
                            amountOut: quote.amountOut || quote.outTokenAmount,
                            priceImpact: quote.priceImpact || 0,
                            fee: quote.feeTier || 500,
                            source: 'real-sdk'
                        };
                    } catch (sdkError) {
                        logMessage(`⚠️ Real SDK quote failed: ${sdkError.message}, falling back to API`, 'warning');
                    }
                }
                
                // Use server endpoint for quotes
                logMessage(`🔍 Getting server quote: ${amountIn} ${getTokenSymbol(tokenIn)} → ${getTokenSymbol(tokenOut)}`, 'info');
                
                // Prepare quote request for server
                const quoteRequest = {
                    tokenIn: tokenIn,
                    tokenOut: tokenOut,
                    amountIn: amountIn.toString(),
                    slippage: '0.5', // Default slippage
                    walletAddress: gswapSDK?.walletAddress || '0x742d35Cc6634C0532925a3b8D0C0E1C4C5f7A8b9'
                };
                
                // Call server endpoint
                let response;
                let workingEndpoint = 'http://localhost:3000/api/quote';
                
                try {
                    logMessage(`🔍 Calling server endpoint: ${workingEndpoint}`, 'info');
                    
                    response = await fetch(workingEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(quoteRequest)
                    });
                    
                    if (response.ok) {
                        logMessage(`✅ Server quote successful`, 'success');
                    } else {
                        logMessage(`⚠️ Server quote failed: ${response.status}`, 'warning');
                        throw new Error(`Server error: ${response.status}`);
                    }
                    
                } catch (serverError) {
                    logMessage(`❌ Server quote error: ${serverError.message}`, 'error');
                    throw new Error(`Server connection failed: ${serverError.message}`);
                }
                
                const data = await response.json();
                
                if (data.success && data.quote) {
                    logMessage(`✅ Server quote received: ${data.quote.amountOut} ${getTokenSymbol(tokenOut)}`, 'success');
                    return {
                        amountOut: data.quote.amountOut,
                        priceImpact: data.quote.priceImpact || 0,
                        fee: data.quote.fee || 500,
                        source: 'server'
                    };
                } else {
                    logMessage(`❌ Server quote failed: ${data.message || 'Unknown error'}`, 'error');
                    return null;
                }
            } catch (error) {
                // Don't log every liquidity error as an error - just as warning
                if (error.message.includes('No pools found with sufficient liquidity')) {
                    logMessage(`⚠️ No liquidity for ${getTokenSymbol(tokenIn)} → ${getTokenSymbol(tokenOut)}`, 'warning');
                } else {
                    logMessage(`Quote error: ${error.message}`, 'error');
                }
                return null;
            }
        }

        // Parse token string to GalaSwap V3 format
        function parseTokenString(tokenString) {
            const parts = tokenString.split('$');
            return {
                collection: parts[0] || '',
                category: parts[1] || 'Unit',
                type: parts[2] || 'none',
                additionalKey: parts[3] || 'none'
            };
        }

        // Sign and execute swap transaction on-chain
        async function signAndExecuteSwap(payload, tokenIn, tokenOut, amountIn, quote) {
            try {
                logMessage(`🔐 Signing transaction payload...`, 'info');
                
                // Use real GalaChain signing if private key is available
                let signature;
                if (privateKeySet && privateKey) {
                    try {
                        signature = signPayloadWithGalaChain(payload);
                        logMessage(`✅ Real signature generated`, 'success');
                    } catch (signError) {
                        logMessage(`❌ Real signing failed: ${signError.message}`, 'error');
                        logMessage(`🔄 Falling back to placeholder signature`, 'warning');
                        signature = '0x' + '0'.repeat(130); // Fallback to placeholder
                    }
                } else {
                    logMessage(`⚠️ No private key set - using placeholder signature`, 'warning');
                    signature = '0x' + '0'.repeat(130); // Placeholder signature
                }
                
                // Prepare the bundle request with the actual swap payload
                // Try different operation types to see which one works
                const bundleRequest = {
                    payload: payload, // This is the payload from /v1/trade/swap response
                    type: 'swap', // Back to swap type - this should be correct for swap operations
                    signature: signature,
                    user: walletAddress
                };
                
        logMessage(`📦 Submitting transaction bundle...`, 'info');
        logMessage(`🔍 Bundle request: ${JSON.stringify(bundleRequest, null, 2)}`, 'info');
        
        // Debug bundle structure
        logMessage(`🔍 Bundle payload keys: ${Object.keys(bundleRequest.payload).join(', ')}`, 'info');
        logMessage(`🔍 Bundle type: ${bundleRequest.type}`, 'info');
        logMessage(`🔍 Bundle signature length: ${bundleRequest.signature.length}`, 'info');
        logMessage(`🔍 Bundle user: ${bundleRequest.user}`, 'info');
                
                // Submit to bundle endpoint for execution
                const bundleResponse = await fetch(`${API_BASE}/v1/trade/bundle`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(bundleRequest)
                });
                
                if (!bundleResponse.ok) {
                    const errorText = await bundleResponse.text();
                    logMessage(`❌ Bundle error response: ${errorText}`, 'error');
                    logMessage(`🔍 Bundle response status: ${bundleResponse.status}`, 'error');
                    logMessage(`🔍 Bundle response headers: ${JSON.stringify(Object.fromEntries(bundleResponse.headers.entries()))}`, 'error');
                    throw new Error(`Bundle submission failed: ${bundleResponse.status} ${bundleResponse.statusText} - ${errorText}`);
                }
                
                const bundleResult = await bundleResponse.json();
                logMessage(`🔍 Full bundle response: ${JSON.stringify(bundleResult)}`, 'info');
                
                if (bundleResult.status === 201 && bundleResult.data) {
                    logMessage(`✅ TRANSACTION SUBMITTED: ${bundleResult.data.data}`, 'success');
                    logMessage(`🔍 Transaction details: ${JSON.stringify(bundleResult.data)}`, 'info');
                    
                    // Transaction submitted successfully - no need for immediate GalaScan verification
                    
                    // Add to permanent transaction history
                    addTransactionToHistory({
                        txHash: bundleResult.data.data,
                        type: 'swap',
                        tokenIn: tokenIn,
                        tokenOut: tokenOut,
                        amountIn: amountIn,
                        amountOut: Number(quote?.amountOut) || 0,
                        status: 'submitted',
                        isSimulation: false,
                        uniqueKey: payload.uniqueKey,
                        bundleId: bundleResult.data.data
                    });
                    
                        return {
                            success: true,
                        txHash: bundleResult.data.data,
                        data: {
                            amountOut: Number(quote?.amountOut) || 0,
                            transactionHash: bundleResult.data.data,
                            uniqueKey: payload.uniqueKey,
                            isSimulation: false // Real on-chain transaction
                        }
                        };
                    } else {
                    throw new Error(`Bundle execution failed: ${bundleResult.message || 'Unknown error'}`);
                }
                
            } catch (error) {
                logMessage(`❌ Transaction execution failed: ${error.message}`, 'error');
                throw error;
            }
        }

        // Execute swap using GalaSwap API
        async function executeSwap(tokenIn, tokenOut, amountIn, quote) {
            try {
                // Check if quote is valid
                if (!quote) {
                    throw new Error('No valid quote available for swap');
                }
                
                // Use real SDK if available, otherwise fallback to direct API
                if (gswapSDK && gswapSDK.signer) {
                    logMessage(`🚀 Executing REAL SDK swap: ${amountIn.toFixed(4)} ${getTokenSymbol(tokenIn)} → ${getTokenSymbol(tokenOut)}`, 'info');
                    
                    try {
                        // Tokens are already in correct format (GALA|Unit|none|none)
                        const tokenInSDK = tokenIn; // Already correct format
                        const tokenOutSDK = tokenOut; // Already correct format
                        
                        // Execute swap using real GSwap SDK
                        const swapResult = await gswapSDK.swaps.swap(
                            tokenInSDK,
                            tokenOutSDK,
                            500, // 0.05% fee tier (most liquid)
                            {
                                exactIn: amountIn.toString(),
                                amountOutMinimum: (Number(quote.amountOut) * 0.95).toString() // 5% slippage
                            }
                        );
                        
                        logMessage(`✅ SDK swap submitted: ${swapResult.txId}`, 'success');
                        
                        // Wait for completion with real-time monitoring
                        try {
                            const completed = await swapResult.wait();
                            logMessage(`🎉 SDK swap completed: ${completed.transactionHash}`, 'success');
                            
                        return {
                                success: true,
                                txHash: completed.transactionHash,
                                txId: completed.txId,
                                data: completed.Data,
                                isSDK: true
                            };
                        } catch (waitError) {
                            logMessage(`⚠️ SDK swap submitted but monitoring failed: ${waitError.message}`, 'warning');
                            return {
                                success: true,
                                txHash: swapResult.txId,
                                txId: swapResult.txId,
                                isSDK: true,
                                monitoringFailed: true
                            };
                        }
                        
                    } catch (sdkError) {
                        logMessage(`❌ SDK swap failed: ${sdkError.message}`, 'error');
                        logMessage(`🔄 Falling back to direct API...`, 'info');
                        // Fall through to direct API
                    }
                }
                
                // Use server endpoint for swap execution
                logMessage(`🔄 Executing server swap: ${amountIn.toFixed(4)} ${getTokenSymbol(tokenIn)} → ${getTokenSymbol(tokenOut)}`, 'info');
                
                // Prepare swap request for server
                const swapRequest = {
                    tokenIn: tokenIn,
                    tokenOut: tokenOut,
                    amountIn: amountIn.toString(),
                    slippage: '0.5', // Default slippage
                    walletAddress: walletAddress || 'eth|089018e67E35BeAAb3F7c28cb0d64dBA04D9268F',
                    privateKey: privateKey || '',
                    quote: quote
                };
                
                logMessage(`🔍 Server swap request prepared`, 'info');
                logMessage(`🔍 Quote data: ${JSON.stringify(quote)}`, 'info');

                // No simulation mode - require real API
                if (!quote) {
                    throw new Error('No quote available - APIs must be working for trading');
                }

                const response = await fetch('http://localhost:3000/api/swap', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(swapRequest)
                });
                
                if (!response.ok) {
                    throw new Error(`Swap failed: ${response.status} ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    const simulationNote = result.isSimulated ? ' (SIMULATED - DEMO MODE)' : ' (REAL ON-CHAIN)';
                    const txHash = result.transactionHash || result.txId || 'PENDING';
                    logMessage(`✅ Server swap successful: ${txHash}${simulationNote}`, 'success');
                    logMessage(`💰 Received: ${result.amountOut} ${getTokenSymbol(tokenOut)}`, 'success');
                    
                    // Add successful transaction to history
                    addTransactionToHistory({
                        txHash: txHash,
                        type: 'swap',
                        tokenIn: tokenIn,
                        tokenOut: tokenOut,
                        amountIn: amountIn,
                        amountOut: Number(result.amountOut) || 0,
                        status: 'success',
                        isSimulation: false,
                        uniqueKey: result.transactionHash,
                        gasUsed: result.gasUsed
                    });
                    
                    return {
                        success: true,
                        txHash: result.transactionHash,
                        data: {
                            amountOut: Number(result.amountOut) || 0,
                            uniqueKey: result.transactionHash,
                            isSimulation: false
                        }
                    };
                } else {
                    throw new Error(`Server swap failed: ${result.message || 'Unknown error'}`);
                }
                
            } catch (error) {
                logMessage(`❌ Swap execution failed: ${error.message}`, 'error');
                return {
                    success: false,
                    error: error.message
                };
            }
        }

        // Monitor individual trades for profit/loss
        function monitorTrade(trade) {
            if (!window.activePositions.includes(trade)) return; // Trade already closed
            
            const currentPrice = tokenPrices[trade.token];
            if (!currentPrice) return;
            
            const profit = (currentPrice - trade.price) / trade.price;
            const profitPercent = profit * 100;
            
            // Check for profit target or stop loss
            const activeConfig = getActiveConfig();
            if (profitPercent >= activeConfig.profitTarget) {
                logMessage(`🎯 Profit target reached for ${trade.symbol}: ${profitPercent.toFixed(2)}%`, 'success');
                executeTrade(trade.token, currentPrice, 'sell', { confidence: 1, reason: 'Profit target reached' });
            } else if (profitPercent <= -activeConfig.stopLoss) {
                logMessage(`🛑 Stop loss triggered for ${trade.symbol}: ${profitPercent.toFixed(2)}%`, 'error');
                executeTrade(trade.token, currentPrice, 'sell', { confidence: 1, reason: 'Stop loss triggered' });
            } else {
                // Continue monitoring
                setTimeout(() => {
                    monitorTrade(trade);
                }, 10000); // Check every 10 seconds
            }
        }

        // Get token symbol from composite key
        function getTokenSymbol(tokenKey) {
            return tokenKey.split('|')[0];
        }

        // Update status display
        function updateStatus() {
            // Recalculate portfolio value before displaying
            portfolioValue = calculatePortfolioValue();
            
            document.getElementById('portfolioValue').textContent = `$${portfolioValue.toFixed(2)}`;
            document.getElementById('totalProfit').textContent = `$${totalProfit.toFixed(2)}`;
            
            // Fix active trades vs total trades consistency
            const actualActiveTrades = Math.max(0, activeTrades);
            const actualTotalTrades = Math.max(totalTrades, tradeHistory.length);
            
            document.getElementById('activeTrades').textContent = actualActiveTrades.toString();
            document.getElementById('totalTrades').textContent = actualTotalTrades.toString();
            
            const winRate = actualTotalTrades > 0 ? (winningTrades / actualTotalTrades * 100).toFixed(1) : 0;
            document.getElementById('winRate').textContent = `${winRate}%`;
            
            // Update color coding for status cards
            updateStatusCardColors(actualActiveTrades, actualTotalTrades, winRate);
            
            // Update profit color
            const profitElement = document.getElementById('totalProfit');
            if (totalProfit > 0) {
                profitElement.style.color = '#4CAF50';
            } else if (totalProfit < 0) {
                profitElement.style.color = '#f44336';
            } else {
                profitElement.style.color = '#ffd700';
            }
            
            // Debug log
            console.log(`Portfolio value updated: $${portfolioValue.toFixed(2)}`);
        }

        // Initialize status display
        function initStatusDisplay() {
            document.getElementById('portfolioValue').textContent = '$0.00';
            document.getElementById('totalProfit').textContent = '$0.00';
            document.getElementById('activeTrades').textContent = '0';
            document.getElementById('totalTrades').textContent = '0';
            document.getElementById('winRate').textContent = '0%';
        }

        // Log messages
        function logMessage(message, type = 'info') {
            const log = document.getElementById('tradingLog');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            
            const timestamp = new Date().toLocaleTimeString();
            logEntry.textContent = `[${timestamp}] ${message}`;
            
            log.appendChild(logEntry);
            log.scrollTop = log.scrollHeight;
            
            // Keep only last 100 log entries
            while (log.children.length > 100) {
                log.removeChild(log.firstChild);
            }
            
            // Enforce heights after adding log entry
            setTimeout(enforceLogHeights, 10);
            
            // Ensure scroll to bottom
            setTimeout(scrollLogsToBottom, 20);
        }

        // Debug log messages
        function debugLog(message, type = 'info') {
            const log = document.getElementById('debugLog');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            
            const timestamp = new Date().toLocaleTimeString();
            logEntry.textContent = `[${timestamp}] ${message}`;
            
            log.appendChild(logEntry);
            log.scrollTop = log.scrollHeight;
            
            // Keep only last 50 debug entries
            while (log.children.length > 50) {
                log.removeChild(log.firstChild);
            }
            
            // Ensure scroll to bottom
            setTimeout(scrollLogsToBottom, 20);
        }

        // Swap log messages
        function logSwap(swapData, type = 'info') {
            const log = document.getElementById('swapsLog');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            
            const timestamp = new Date().toLocaleTimeString();
            let message = '';
            
            if (type === 'success') {
                const amountIn = typeof swapData.amountIn === 'number' ? swapData.amountIn.toFixed(4) : '0.0000';
                const amountOut = typeof swapData.amountOut === 'number' ? swapData.amountOut.toFixed(4) : '0.0000';
                message = `✅ ${swapData.direction}: ${amountIn} ${swapData.tokenIn} → ${amountOut} ${swapData.tokenOut} | TX: ${swapData.txHash}`;
            } else if (type === 'error') {
                const amountIn = typeof swapData.amountIn === 'number' ? swapData.amountIn.toFixed(4) : '0.0000';
                message = `❌ ${swapData.direction}: ${amountIn} ${swapData.tokenIn} → ${swapData.tokenOut} | Error: ${swapData.error}`;
            } else {
                const amountIn = typeof swapData.amountIn === 'number' ? swapData.amountIn.toFixed(4) : '0.0000';
                message = `🔄 ${swapData.direction}: ${amountIn} ${swapData.tokenIn} → ${swapData.tokenOut}`;
            }
            
            logEntry.textContent = `[${timestamp}] ${message}`;
            log.appendChild(logEntry);
            log.scrollTop = log.scrollHeight;
            
            // Keep only last 100 swap entries
            while (log.children.length > 100) {
                log.removeChild(log.firstChild);
            }
            
            // Ensure scroll to bottom
            setTimeout(scrollLogsToBottom, 20);
        }

        // Update swap statistics
        function updateSwapStats() {
            console.log('Updating swap stats...');
            console.log('totalSwaps:', totalSwaps);
            
            const totalSwapsEl = document.getElementById('totalSwaps');
            const successfulSwapsEl = document.getElementById('successfulSwaps');
            const failedSwapsEl = document.getElementById('failedSwaps');
            
            console.log('Elements found:', {
                totalSwaps: !!totalSwapsEl,
                successfulSwaps: !!successfulSwapsEl,
                failedSwaps: !!failedSwapsEl
            });
            
            if (totalSwapsEl) totalSwapsEl.textContent = totalSwaps.toString();
            if (successfulSwapsEl) successfulSwapsEl.textContent = successfulSwaps.toString();
            if (failedSwapsEl) failedSwapsEl.textContent = failedSwaps.toString();
            
            const successRate = totalSwaps > 0 ? (successfulSwaps / totalSwaps * 100).toFixed(1) : 0;
            document.getElementById('swapSuccessRate').textContent = `${successRate}%`;
            
            // Calculate additional statistics
            const completedTrades = tradeHistory.length;
            const avgProfit = completedTrades > 0 ? (totalProfit / completedTrades).toFixed(2) : 0;
            const bestTrade = completedTrades > 0 ? Math.max(...tradeHistory.map(t => t.profit)).toFixed(2) : 0;
            const worstTrade = completedTrades > 0 ? Math.min(...tradeHistory.map(t => t.profit)).toFixed(2) : 0;
            
            document.getElementById('avgProfit').textContent = `$${avgProfit}`;
            document.getElementById('bestTrade').textContent = `$${bestTrade}`;
            document.getElementById('worstTrade').textContent = `$${worstTrade}`;
            
            // Update last trade time
            const lastTradeTimeElement = document.getElementById('lastTradeTime');
            if (tradeHistory.length > 0) {
                const lastTrade = tradeHistory[tradeHistory.length - 1];
                const lastTradeDate = new Date(lastTrade.timestamp);
                const timeAgo = getTimeAgo(lastTradeDate);
                lastTradeTimeElement.textContent = timeAgo;
                lastTradeTimeElement.className = 'summary-value';
            } else {
                lastTradeTimeElement.textContent = 'No trades yet';
                lastTradeTimeElement.className = 'summary-value';
            }
            
            // Update bot uptime
            const botUptimeElement = document.getElementById('botUptime');
            if (botStartTime) {
                const uptime = Date.now() - botStartTime;
                const hours = Math.floor(uptime / (1000 * 60 * 60));
                const minutes = Math.floor((uptime % (1000 * 60 * 60)) / (1000 * 60));
                botUptimeElement.textContent = `${hours}h ${minutes}m`;
            } else {
                botUptimeElement.textContent = '0h 0m';
            }
            
            // Color code success rate
            const successRateElement = document.getElementById('swapSuccessRate');
            if (successRate >= 80) {
                successRateElement.className = 'summary-value positive';
            } else if (successRate >= 60) {
                successRateElement.className = 'summary-value';
            } else {
                successRateElement.className = 'summary-value negative';
            }
            
            // Color code average profit
            const avgProfitElement = document.getElementById('avgProfit');
            if (avgProfit > 0) {
                avgProfitElement.className = 'summary-value positive';
            } else if (avgProfit < 0) {
                avgProfitElement.className = 'summary-value negative';
            } else {
                avgProfitElement.className = 'summary-value';
            }
        }

        // Helper function to get time ago
        function getTimeAgo(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / (1000 * 60));
            const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
            const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
            
            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            return `${diffDays}d ago`;
        }

        // Update status card colors
        function updateStatusCardColors(activeTrades, totalTrades, winRate) {
            const activeTradesElement = document.getElementById('activeTrades');
            const totalTradesElement = document.getElementById('totalTrades');
            const winRateElement = document.getElementById('winRate');
            
            // Color code active trades
            if (activeTrades > 0) {
                activeTradesElement.className = 'value positive';
            } else {
                activeTradesElement.className = 'value';
            }
            
            // Color code total trades
            if (totalTrades > 0) {
                totalTradesElement.className = 'value positive';
            } else {
                totalTradesElement.className = 'value';
            }
            
            // Color code win rate
            if (winRate >= 80) {
                winRateElement.className = 'value positive';
            } else if (winRate >= 60) {
                winRateElement.className = 'value';
            } else if (winRate > 0) {
                winRateElement.className = 'value negative';
            } else {
                winRateElement.className = 'value';
            }
        }

        // Configuration functions
        function openConfig() {
            document.getElementById('configPanel').style.display = 'block';
        }

        function closeConfig() {
            document.getElementById('configPanel').style.display = 'none';
        }

        function saveConfig() {
            // Get current mode
            const currentMode = tradingMode;
            
            // Save common settings
            const riskLevel = document.getElementById('riskLevel').value;
            const maxPositionSize = parseInt(document.getElementById('maxPositionSize').value);
            const profitTarget = parseInt(document.getElementById('profitTarget').value);
            const stopLoss = parseInt(document.getElementById('stopLoss').value);
            const scanInterval = parseInt(document.getElementById('scanInterval').value);
            
            // Update active configuration based on current mode
            const activeConfig = getActiveConfig();
            activeConfig.riskLevel = riskLevel;
            activeConfig.maxPositionSize = maxPositionSize;
            activeConfig.profitTarget = profitTarget;
            activeConfig.stopLoss = stopLoss;
            activeConfig.scanInterval = scanInterval;
            
            // Save mode-specific settings
            switch(currentMode) {
                case 'conservative':
                    conservativeConfig.arbitrageThreshold = parseFloat(document.getElementById('conservativeArbitrageThreshold').value);
                    conservativeConfig.buyThreshold = parseFloat(document.getElementById('conservativeBuyThreshold').value);
                    conservativeConfig.sellThreshold = parseFloat(document.getElementById('conservativeSellThreshold').value);
                    
                    logMessage('⚙️ Conservative Mode configuration saved', 'info');
                    logMessage(`🛡️ CONSERVATIVE: ${conservativeConfig.scanInterval}s scan, ${conservativeConfig.arbitrageThreshold}% arbitrage, ${conservativeConfig.buyThreshold} buy threshold`, 'info');
                    break;
                    
                case 'tradecap':
                    tradeCapConfig.maxTradeAmount = parseInt(document.getElementById('maxTradeAmount').value);
                    tradeCapConfig.arbitrageThreshold = parseFloat(document.getElementById('tradeCapArbitrageThreshold').value);
                    tradeCapConfig.buyThreshold = parseFloat(document.getElementById('tradeCapBuyThreshold').value);
                    tradeCapConfig.sellThreshold = parseFloat(document.getElementById('tradeCapSellThreshold').value);
                    
                    logMessage('⚙️ Trade Cap Mode configuration saved', 'info');
                    logMessage(`🔒 TRADE CAP: ${tradeCapConfig.scanInterval}s scan, ${tradeCapConfig.maxTradeAmount} GALA max, ${tradeCapConfig.arbitrageThreshold}% arbitrage`, 'info');
                    break;
                    
                case 'competition':
                    competitionConfig.maxTradesPerSecond = parseInt(document.getElementById('maxTradesPerSecond').value);
                    competitionConfig.concurrentTrades = parseInt(document.getElementById('concurrentTrades').value);
                    competitionConfig.arbitrageThreshold = parseFloat(document.getElementById('arbitrageThreshold').value);
                    competitionConfig.buyThreshold = parseFloat(document.getElementById('competitionBuyThreshold').value);
                    competitionConfig.sellThreshold = parseFloat(document.getElementById('competitionSellThreshold').value);
                    
                    logMessage('⚙️ Competition Mode configuration saved', 'info');
                    logMessage(`🏆 COMPETITION: ${competitionConfig.scanInterval}s scan, ${competitionConfig.maxTradesPerSecond} trades/sec, ${competitionConfig.concurrentTrades} concurrent`, 'info');
                    break;
            }
            
            // Save configuration to localStorage
            saveBotConfig();
            
            closeConfig();
        }

        // Toggle trade cap mode
        function toggleTradeCap() {
            tradeCapMode = document.getElementById('tradeCapToggle').checked;
            const modeText = tradeCapMode ? 'TRADE CAP' : 'FULL TRADES';
            logMessage(`🔄 Switched to ${modeText} - ${tradeCapMode ? 'Small trades (5-25 GALA)' : 'Full position sizes'}`, 'info');
            
            // Update the mode banner
            updateModeBanner();
        }

        // Update mode banner based on current trading mode
        function updateModeBanner() {
            const modeBanner = document.getElementById('modeBanner');
            if (!modeBanner) {
                console.log('❌ Mode banner element not found');
                return;
            }
            
            console.log(`🔄 Updating mode banner for mode: ${tradingMode}`);
            console.log(`🔍 Current banner text: "${modeBanner.textContent}"`);
            
            let bannerText = '';
            let color = '';
            let background = '';
            
            switch (tradingMode) {
                case 'conservative':
                    bannerText = '🛡️ CONSERVATIVE MODE - Safe & Steady Trading';
                    color = '#4caf50';
                    background = 'rgba(76, 175, 80, 0.1)';
                    break;
                case 'tradecap':
                    bannerText = '🔒 TRADE CAP MODE - Small trades (5-25 GALA)';
                    color = '#ff9800';
                    background = 'rgba(255, 152, 0, 0.1)';
                    break;
                case 'competition':
                    bannerText = '🏆 COMPETITION MODE - High-Frequency Trading';
                    color = '#9c27b0';
                    background = 'rgba(156, 39, 176, 0.1)';
                    break;
                default:
                    bannerText = '🚀 GalaSwap Trading Bot v9.1';
                    color = '#2196f3';
                    background = 'rgba(33, 150, 243, 0.1)';
            }
            
            console.log(`🔧 Setting banner text to: "${bannerText}"`);
            console.log(`🔧 Setting banner color to: ${color}`);
            console.log(`🔧 Setting banner background to: ${background}`);
            
            modeBanner.textContent = bannerText;
            modeBanner.style.color = color;
            modeBanner.style.background = background;
            
            console.log(`✅ Mode banner updated: "${bannerText}"`);
            console.log(`🔍 Banner text after update: "${modeBanner.textContent}"`);
        }

        // Test function to verify mode switching works
        function testModeSwitching() {
            console.log('🧪 Testing mode switching...');
            console.log(`Current mode: ${tradingMode}`);
            
            // Test all three modes
            const modes = ['conservative', 'tradecap', 'competition'];
            let currentIndex = modes.indexOf(tradingMode);
            let nextIndex = (currentIndex + 1) % modes.length;
            let nextMode = modes[nextIndex];
            
            console.log(`Switching from ${tradingMode} to ${nextMode}`);
            setTradingMode(nextMode);
        }

        // Set trading mode (3-mode system)
        function setTradingMode(mode) {
            console.log(`🔄 setTradingMode called with: ${mode}`);
            tradingMode = mode;
            
            // Update legacy variables for compatibility
            tradeCapMode = (mode === 'tradecap');
            competitionMode = (mode === 'competition');
            
            // Get active configuration
            const activeConfig = getActiveConfig();
            
            // Update UI elements
            updateModeUI(mode, activeConfig);
            
            // Log mode change
            logModeChange(mode, activeConfig);
            
            // Update radio buttons
            const radioButtons = document.querySelectorAll('input[name="tradingMode"]');
            radioButtons.forEach(radio => {
                radio.checked = (radio.value === mode);
            });
            
            // Update select dropdown
            const selectDropdown = document.getElementById('tradingModeSelect');
            if (selectDropdown) {
                selectDropdown.value = mode;
            }
            
            // Update current mode display
            updateCurrentModeDisplay(mode);
            
            // Update mode banner
            updateModeBanner();
            
            // Save bot configuration when mode changes
            saveBotConfig();
        }
        
        // Get active configuration based on current mode
        function getActiveConfig() {
            switch(tradingMode) {
                case 'conservative': return conservativeConfig;
                case 'tradecap': return tradeCapConfig;
                case 'competition': return competitionConfig;
                default: return conservativeConfig;
            }
        }
        
        // Update UI elements based on mode
        function updateModeUI(mode, config) {
            // Update scan interval input
            const scanIntervalInput = document.getElementById('scanInterval');
            if (scanIntervalInput && config) {
                scanIntervalInput.value = config.scanInterval;
            }
            
            // Show/hide mode-specific settings
            const conservativeSettings = document.getElementById('conservativeSettings');
            const competitionSettings = document.getElementById('competitionSettings');
            const tradeCapSettings = document.getElementById('tradeCapSettings');
            
            if (conservativeSettings) {
                conservativeSettings.style.display = (mode === 'conservative') ? 'block' : 'none';
            }
            
            if (competitionSettings) {
                competitionSettings.style.display = (mode === 'competition') ? 'block' : 'none';
            }
            
            if (tradeCapSettings) {
                tradeCapSettings.style.display = (mode === 'tradecap') ? 'block' : 'none';
            }
            
            // Update mode selector in config panel
            const tradingModeSelect = document.getElementById('tradingModeSelect');
            if (tradingModeSelect) {
                tradingModeSelect.value = mode;
            }
            
            // Save bot configuration when mode changes
            saveBotConfig();
        }
        
        // Toggle competition mode
        function toggleCompetitionMode() {
            competitionMode = !competitionMode;
            const modeText = competitionMode ? 'COMPETITION' : 'STANDARD';
            logMessage(`🔄 Switched to ${modeText} - ${competitionMode ? 'All tokens enabled' : 'High liquidity only'}`, 'info');
            
            // Update the mode banner
            updateModeBanner();
            
            // Save bot configuration when mode changes
            saveBotConfig();
            
            // Update current mode display in config panel
            const currentModeDisplay = document.getElementById('currentModeDisplay');
            if (currentModeDisplay) {
                const modeInfo = {
                    'conservative': { text: '🛡️ CONSERVATIVE MODE', desc: 'Safe & Steady Trading', color: '#4caf50', bg: 'rgba(76, 175, 80, 0.1)' },
                    'tradecap': { text: '🔒 TRADE CAP MODE', desc: 'Small Testing Trades', color: '#ff9800', bg: 'rgba(255, 152, 0, 0.1)' },
                    'competition': { text: '🏆 COMPETITION MODE', desc: 'High-Frequency Trading', color: '#9c27b0', bg: 'rgba(156, 39, 176, 0.1)' }
                };
                
                const info = modeInfo[mode];
                currentModeDisplay.textContent = info.text;
                currentModeDisplay.style.color = info.color;
                currentModeDisplay.style.background = info.bg;
                
                // Update description
                const descElement = currentModeDisplay.nextElementSibling;
                if (descElement) {
                    descElement.textContent = info.desc;
                }
            }
        }
        
        // Log mode change with detailed information
        function logModeChange(mode, config) {
            const modeNames = {
                'conservative': '🛡️ CONSERVATIVE MODE',
                'tradecap': '🔒 TRADE CAP MODE', 
                'competition': '🏆 COMPETITION MODE'
            };
            
            logMessage(`🔄 Switched to ${modeNames[mode]}`, 'info');
            
            // Log mode-specific features
            switch(mode) {
                case 'conservative':
                    logMessage(`📊 CONSERVATIVE FEATURES:`, 'success');
                    logMessage(`   • 10-second scanning (slow & steady)`, 'info');
                    logMessage(`   • 1 trade/second (conservative)`, 'info');
                    logMessage(`   • High-liquidity pairs only`, 'info');
                    logMessage(`   • Tight stop loss (2%)`, 'info');
                    logMessage(`   • High profit target (5%)`, 'info');
                    break;
                    
                case 'tradecap':
                    logMessage(`🔒 TRADE CAP FEATURES:`, 'success');
                    logMessage(`   • 5-second scanning (medium speed)`, 'info');
                    logMessage(`   • 2 trades/second (limited)`, 'info');
                    logMessage(`   • Small trades (5-25 GALA)`, 'info');
                    logMessage(`   • Very tight stop loss (1%)`, 'info');
                    logMessage(`   • Quick profit target (2%)`, 'info');
                    break;
                    
                case 'competition':
                    logMessage(`⚡ COMPETITION FEATURES:`, 'success');
                    logMessage(`   • 1-second scanning (ultra-fast)`, 'info');
                    logMessage(`   • 5 trades/second (high-frequency)`, 'info');
                    logMessage(`   • 3 concurrent trades (parallel)`, 'info');
                    logMessage(`   • All tokens + Triangle arbitrage`, 'info');
                    logMessage(`   • Lower thresholds (1% arbitrage)`, 'info');
                    break;
            }
        }

        // Bot initialization is handled in DOMContentLoaded event listener above
    </script>
</body>
</html>
